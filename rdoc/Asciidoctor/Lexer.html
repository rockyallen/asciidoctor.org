<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class Asciidoctor::Lexer - API Documentation for Asciidoctor 0.1.4.rc.1</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/asciidoctor/lexer.rb
    <li>lib/asciidoctor/substituters.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    <nav id="sections-section" class="section">
  <h3 class="section-header">Sections</h3>
  <ul class="link-list">
    
      <li><a href="#5Buntitled-5D"></a></li>
    
      <li><a href="#Public">Public</a></li>
    
      <li><a href="#Internal">Internal</a></li>
    
  </ul>
</nav>

    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link"><a href="../Object.html">Object</a>
  
</nav>

    
    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li ><a href="#method-c-build_block">::build_block</a>
    
    <li ><a href="#method-c-catalog_callouts">::catalog_callouts</a>
    
    <li ><a href="#method-c-catalog_inline_anchors">::catalog_inline_anchors</a>
    
    <li ><a href="#method-c-initialize_section">::initialize_section</a>
    
    <li ><a href="#method-c-is_delimited_block-3F">::is_delimited_block?</a>
    
    <li ><a href="#method-c-is_next_line_document_title-3F">::is_next_line_document_title?</a>
    
    <li ><a href="#method-c-is_next_line_section-3F">::is_next_line_section?</a>
    
    <li ><a href="#method-c-is_section_title-3F">::is_section_title?</a>
    
    <li ><a href="#method-c-is_sibling_list_item-3F">::is_sibling_list_item?</a>
    
    <li ><a href="#method-c-is_single_line_section_title-3F">::is_single_line_section_title?</a>
    
    <li ><a href="#method-c-is_two_line_section_title-3F">::is_two_line_section_title?</a>
    
    <li ><a href="#method-c-line_length">::line_length</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-next_block">::next_block</a>
    
    <li ><a href="#method-c-next_labeled_list">::next_labeled_list</a>
    
    <li ><a href="#method-c-next_list_item">::next_list_item</a>
    
    <li ><a href="#method-c-next_outline_list">::next_outline_list</a>
    
    <li ><a href="#method-c-next_section">::next_section</a>
    
    <li ><a href="#method-c-next_table">::next_table</a>
    
    <li ><a href="#method-c-parse">::parse</a>
    
    <li ><a href="#method-c-parse_block_metadata_line">::parse_block_metadata_line</a>
    
    <li ><a href="#method-c-parse_block_metadata_lines">::parse_block_metadata_lines</a>
    
    <li ><a href="#method-c-parse_blocks">::parse_blocks</a>
    
    <li ><a href="#method-c-parse_cell_spec">::parse_cell_spec</a>
    
    <li ><a href="#method-c-parse_col_specs">::parse_col_specs</a>
    
    <li ><a href="#method-c-parse_document_header">::parse_document_header</a>
    
    <li ><a href="#method-c-parse_header_metadata">::parse_header_metadata</a>
    
    <li ><a href="#method-c-parse_manpage_header">::parse_manpage_header</a>
    
    <li ><a href="#method-c-parse_section_title">::parse_section_title</a>
    
    <li ><a href="#method-c-parse_style_attribute">::parse_style_attribute</a>
    
    <li ><a href="#method-c-process_attribute_entries">::process_attribute_entries</a>
    
    <li ><a href="#method-c-process_attribute_entry">::process_attribute_entry</a>
    
    <li ><a href="#method-c-process_authors">::process_authors</a>
    
    <li ><a href="#method-c-read_lines_for_list_item">::read_lines_for_list_item</a>
    
    <li ><a href="#method-c-reset_block_indent-21">::reset_block_indent!</a>
    
    <li ><a href="#method-c-resolve_list_marker">::resolve_list_marker</a>
    
    <li ><a href="#method-c-resolve_ordered_list_marker">::resolve_ordered_list_marker</a>
    
    <li ><a href="#method-c-roman_numeral_to_int">::roman_numeral_to_int</a>
    
    <li ><a href="#method-c-sanitize_attribute_name">::sanitize_attribute_name</a>
    
    <li ><a href="#method-c-section_level">::section_level</a>
    
    <li ><a href="#method-c-single_line_section_level">::single_line_section_level</a>
    
    <li ><a href="#method-c-store_attribute">::store_attribute</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../README_adoc.html">README.adoc</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Asciidoctor.html">Asciidoctor</a>
  
    <li><a href="../Asciidoctor/AbstractBlock.html">Asciidoctor::AbstractBlock</a>
  
    <li><a href="../Asciidoctor/AbstractNode.html">Asciidoctor::AbstractNode</a>
  
    <li><a href="../Asciidoctor/AttributeList.html">Asciidoctor::AttributeList</a>
  
    <li><a href="../Asciidoctor/BaseTemplate.html">Asciidoctor::BaseTemplate</a>
  
    <li><a href="../Asciidoctor/Block.html">Asciidoctor::Block</a>
  
    <li><a href="../Asciidoctor/Callouts.html">Asciidoctor::Callouts</a>
  
    <li><a href="../Asciidoctor/Cli.html">Asciidoctor::Cli</a>
  
    <li><a href="../Asciidoctor/Cli/Invoker.html">Asciidoctor::Cli::Invoker</a>
  
    <li><a href="../Asciidoctor/Cli/Options.html">Asciidoctor::Cli::Options</a>
  
    <li><a href="../Asciidoctor/Compliance.html">Asciidoctor::Compliance</a>
  
    <li><a href="../Asciidoctor/Debug.html">Asciidoctor::Debug</a>
  
    <li><a href="../Asciidoctor/DocBook45.html">Asciidoctor::DocBook45</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockAdmonitionTemplate.html">Asciidoctor::DocBook45::BlockAdmonitionTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockAudioTemplate.html">Asciidoctor::DocBook45::BlockAudioTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockColistTemplate.html">Asciidoctor::DocBook45::BlockColistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockDlistTemplate.html">Asciidoctor::DocBook45::BlockDlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockExampleTemplate.html">Asciidoctor::DocBook45::BlockExampleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockFloatingTitleTemplate.html">Asciidoctor::DocBook45::BlockFloatingTitleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockImageTemplate.html">Asciidoctor::DocBook45::BlockImageTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockListingTemplate.html">Asciidoctor::DocBook45::BlockListingTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockLiteralTemplate.html">Asciidoctor::DocBook45::BlockLiteralTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockOlistTemplate.html">Asciidoctor::DocBook45::BlockOlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockOpenTemplate.html">Asciidoctor::DocBook45::BlockOpenTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockPageBreakTemplate.html">Asciidoctor::DocBook45::BlockPageBreakTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockParagraphTemplate.html">Asciidoctor::DocBook45::BlockParagraphTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockPassTemplate.html">Asciidoctor::DocBook45::BlockPassTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockPreambleTemplate.html">Asciidoctor::DocBook45::BlockPreambleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockQuoteTemplate.html">Asciidoctor::DocBook45::BlockQuoteTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockRulerTemplate.html">Asciidoctor::DocBook45::BlockRulerTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockSidebarTemplate.html">Asciidoctor::DocBook45::BlockSidebarTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockTableTemplate.html">Asciidoctor::DocBook45::BlockTableTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockTocTemplate.html">Asciidoctor::DocBook45::BlockTocTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockUlistTemplate.html">Asciidoctor::DocBook45::BlockUlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockVerseTemplate.html">Asciidoctor::DocBook45::BlockVerseTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockVideoTemplate.html">Asciidoctor::DocBook45::BlockVideoTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/DocumentTemplate.html">Asciidoctor::DocBook45::DocumentTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/EmbeddedTemplate.html">Asciidoctor::DocBook45::EmbeddedTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineAnchorTemplate.html">Asciidoctor::DocBook45::InlineAnchorTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineBreakTemplate.html">Asciidoctor::DocBook45::InlineBreakTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineButtonTemplate.html">Asciidoctor::DocBook45::InlineButtonTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineCalloutTemplate.html">Asciidoctor::DocBook45::InlineCalloutTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineFootnoteTemplate.html">Asciidoctor::DocBook45::InlineFootnoteTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineImageTemplate.html">Asciidoctor::DocBook45::InlineImageTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineIndextermTemplate.html">Asciidoctor::DocBook45::InlineIndextermTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineKbdTemplate.html">Asciidoctor::DocBook45::InlineKbdTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineMenuTemplate.html">Asciidoctor::DocBook45::InlineMenuTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineQuotedTemplate.html">Asciidoctor::DocBook45::InlineQuotedTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/SectionTemplate.html">Asciidoctor::DocBook45::SectionTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5.html">Asciidoctor::DocBook5</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockAdmonitionTemplate.html">Asciidoctor::DocBook5::BlockAdmonitionTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockAudioTemplate.html">Asciidoctor::DocBook5::BlockAudioTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockColistTemplate.html">Asciidoctor::DocBook5::BlockColistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockDlistTemplate.html">Asciidoctor::DocBook5::BlockDlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockExampleTemplate.html">Asciidoctor::DocBook5::BlockExampleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockFloatingTitleTemplate.html">Asciidoctor::DocBook5::BlockFloatingTitleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockImageTemplate.html">Asciidoctor::DocBook5::BlockImageTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockListingTemplate.html">Asciidoctor::DocBook5::BlockListingTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockLiteralTemplate.html">Asciidoctor::DocBook5::BlockLiteralTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockOlistTemplate.html">Asciidoctor::DocBook5::BlockOlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockOpenTemplate.html">Asciidoctor::DocBook5::BlockOpenTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockPageBreakTemplate.html">Asciidoctor::DocBook5::BlockPageBreakTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockParagraphTemplate.html">Asciidoctor::DocBook5::BlockParagraphTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockPassTemplate.html">Asciidoctor::DocBook5::BlockPassTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockPreambleTemplate.html">Asciidoctor::DocBook5::BlockPreambleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockQuoteTemplate.html">Asciidoctor::DocBook5::BlockQuoteTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockRulerTemplate.html">Asciidoctor::DocBook5::BlockRulerTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockSidebarTemplate.html">Asciidoctor::DocBook5::BlockSidebarTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockTableTemplate.html">Asciidoctor::DocBook5::BlockTableTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockTocTemplate.html">Asciidoctor::DocBook5::BlockTocTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockUlistTemplate.html">Asciidoctor::DocBook5::BlockUlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockVerseTemplate.html">Asciidoctor::DocBook5::BlockVerseTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/BlockVideoTemplate.html">Asciidoctor::DocBook5::BlockVideoTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/DocumentTemplate.html">Asciidoctor::DocBook5::DocumentTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/EmbeddedTemplate.html">Asciidoctor::DocBook5::EmbeddedTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineAnchorTemplate.html">Asciidoctor::DocBook5::InlineAnchorTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineBreakTemplate.html">Asciidoctor::DocBook5::InlineBreakTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineButtonTemplate.html">Asciidoctor::DocBook5::InlineButtonTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineCalloutTemplate.html">Asciidoctor::DocBook5::InlineCalloutTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineFootnoteTemplate.html">Asciidoctor::DocBook5::InlineFootnoteTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineImageTemplate.html">Asciidoctor::DocBook5::InlineImageTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineIndextermTemplate.html">Asciidoctor::DocBook5::InlineIndextermTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineKbdTemplate.html">Asciidoctor::DocBook5::InlineKbdTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineMenuTemplate.html">Asciidoctor::DocBook5::InlineMenuTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/InlineQuotedTemplate.html">Asciidoctor::DocBook5::InlineQuotedTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook5/SectionTemplate.html">Asciidoctor::DocBook5::SectionTemplate</a>
  
    <li><a href="../Asciidoctor/Document.html">Asciidoctor::Document</a>
  
    <li><a href="../Asciidoctor/EmptyTemplate.html">Asciidoctor::EmptyTemplate</a>
  
    <li><a href="../Asciidoctor/Extensions.html">Asciidoctor::Extensions</a>
  
    <li><a href="../Asciidoctor/Extensions/BlockMacroProcessor.html">Asciidoctor::Extensions::BlockMacroProcessor</a>
  
    <li><a href="../Asciidoctor/Extensions/BlockProcessor.html">Asciidoctor::Extensions::BlockProcessor</a>
  
    <li><a href="../Asciidoctor/Extensions/Extension.html">Asciidoctor::Extensions::Extension</a>
  
    <li><a href="../Asciidoctor/Extensions/IncludeProcessor.html">Asciidoctor::Extensions::IncludeProcessor</a>
  
    <li><a href="../Asciidoctor/Extensions/InlineMacroProcessor.html">Asciidoctor::Extensions::InlineMacroProcessor</a>
  
    <li><a href="../Asciidoctor/Extensions/MacroProcessor.html">Asciidoctor::Extensions::MacroProcessor</a>
  
    <li><a href="../Asciidoctor/Extensions/Postprocessor.html">Asciidoctor::Extensions::Postprocessor</a>
  
    <li><a href="../Asciidoctor/Extensions/Preprocessor.html">Asciidoctor::Extensions::Preprocessor</a>
  
    <li><a href="../Asciidoctor/Extensions/Processor.html">Asciidoctor::Extensions::Processor</a>
  
    <li><a href="../Asciidoctor/Extensions/Registry.html">Asciidoctor::Extensions::Registry</a>
  
    <li><a href="../Asciidoctor/Extensions/Treeprocessor.html">Asciidoctor::Extensions::Treeprocessor</a>
  
    <li><a href="../Asciidoctor/HTML5.html">Asciidoctor::HTML5</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockAdmonitionTemplate.html">Asciidoctor::HTML5::BlockAdmonitionTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockAudioTemplate.html">Asciidoctor::HTML5::BlockAudioTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockColistTemplate.html">Asciidoctor::HTML5::BlockColistTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockDlistTemplate.html">Asciidoctor::HTML5::BlockDlistTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockExampleTemplate.html">Asciidoctor::HTML5::BlockExampleTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockFloatingTitleTemplate.html">Asciidoctor::HTML5::BlockFloatingTitleTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockImageTemplate.html">Asciidoctor::HTML5::BlockImageTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockListingTemplate.html">Asciidoctor::HTML5::BlockListingTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockLiteralTemplate.html">Asciidoctor::HTML5::BlockLiteralTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockOlistTemplate.html">Asciidoctor::HTML5::BlockOlistTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockOpenTemplate.html">Asciidoctor::HTML5::BlockOpenTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockPageBreakTemplate.html">Asciidoctor::HTML5::BlockPageBreakTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockParagraphTemplate.html">Asciidoctor::HTML5::BlockParagraphTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockPassTemplate.html">Asciidoctor::HTML5::BlockPassTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockPreambleTemplate.html">Asciidoctor::HTML5::BlockPreambleTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockQuoteTemplate.html">Asciidoctor::HTML5::BlockQuoteTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockRulerTemplate.html">Asciidoctor::HTML5::BlockRulerTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockSidebarTemplate.html">Asciidoctor::HTML5::BlockSidebarTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockTableTemplate.html">Asciidoctor::HTML5::BlockTableTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockTocTemplate.html">Asciidoctor::HTML5::BlockTocTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockUlistTemplate.html">Asciidoctor::HTML5::BlockUlistTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockVerseTemplate.html">Asciidoctor::HTML5::BlockVerseTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockVideoTemplate.html">Asciidoctor::HTML5::BlockVideoTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/DocumentTemplate.html">Asciidoctor::HTML5::DocumentTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/EmbeddedTemplate.html">Asciidoctor::HTML5::EmbeddedTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineAnchorTemplate.html">Asciidoctor::HTML5::InlineAnchorTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineBreakTemplate.html">Asciidoctor::HTML5::InlineBreakTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineButtonTemplate.html">Asciidoctor::HTML5::InlineButtonTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineCalloutTemplate.html">Asciidoctor::HTML5::InlineCalloutTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineFootnoteTemplate.html">Asciidoctor::HTML5::InlineFootnoteTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineImageTemplate.html">Asciidoctor::HTML5::InlineImageTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineIndextermTemplate.html">Asciidoctor::HTML5::InlineIndextermTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineKbdTemplate.html">Asciidoctor::HTML5::InlineKbdTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineMenuTemplate.html">Asciidoctor::HTML5::InlineMenuTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineQuotedTemplate.html">Asciidoctor::HTML5::InlineQuotedTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/SectionTemplate.html">Asciidoctor::HTML5::SectionTemplate</a>
  
    <li><a href="../Asciidoctor/Helpers.html">Asciidoctor::Helpers</a>
  
    <li><a href="../Asciidoctor/Inline.html">Asciidoctor::Inline</a>
  
    <li><a href="../Asciidoctor/Lexer.html">Asciidoctor::Lexer</a>
  
    <li><a href="../Asciidoctor/List.html">Asciidoctor::List</a>
  
    <li><a href="../Asciidoctor/ListItem.html">Asciidoctor::ListItem</a>
  
    <li><a href="../Asciidoctor/PathResolver.html">Asciidoctor::PathResolver</a>
  
    <li><a href="../Asciidoctor/PreprocessorReader.html">Asciidoctor::PreprocessorReader</a>
  
    <li><a href="../Asciidoctor/Reader.html">Asciidoctor::Reader</a>
  
    <li><a href="../Asciidoctor/Reader/Cursor.html">Asciidoctor::Reader::Cursor</a>
  
    <li><a href="../Asciidoctor/Renderer.html">Asciidoctor::Renderer</a>
  
    <li><a href="../Asciidoctor/SafeMode.html">Asciidoctor::SafeMode</a>
  
    <li><a href="../Asciidoctor/Section.html">Asciidoctor::Section</a>
  
    <li><a href="../Asciidoctor/Substituters.html">Asciidoctor::Substituters</a>
  
    <li><a href="../Asciidoctor/Table.html">Asciidoctor::Table</a>
  
    <li><a href="../Asciidoctor/Table/Cell.html">Asciidoctor::Table::Cell</a>
  
    <li><a href="../Asciidoctor/Table/Column.html">Asciidoctor::Table::Column</a>
  
    <li><a href="../Asciidoctor/Table/ParserContext.html">Asciidoctor::Table::ParserContext</a>
  
    <li><a href="../Asciidoctor/TemplateCache.html">Asciidoctor::TemplateCache</a>
  
    <li><a href="../Object.html">Object</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class Asciidoctor::Lexer</h1>

  <div id="description" class="description">
    
<p>Methods to parse lines of AsciiDoc into an object hierarchyrepresenting the
structure of the document. All methods are class methods andshould be
invoked from the <a href="Lexer.html">Lexer</a> class. The main entry point
is <a href="Lexer.html#method-c-next_block">::next_block</a>.No <a
href="Lexer.html">Lexer</a> instances shall be discovered running around.
(Any attempt toinstantiate a <a href="Lexer.html">Lexer</a> will be
futile).</p>

<p>The object hierarchy created by the <a href="Lexer.html">Lexer</a> consists
of zero or more Sectionand <a href="Block.html">Block</a> objects. <a
href="Section.html">Section</a> objects may be nested and a <a
href="Section.html">Section</a> objectcontains zero or more <a
href="Block.html">Block</a> objects. <a href="Block.html">Block</a> objects
may be nested, but mayonly contain other <a href="Block.html">Block</a>
objects. <a href="Block.html">Block</a> objects which represent lists
maycontain zero or more <a href="ListItem.html">ListItem</a> objects.</p>

<h3 id="label-Examples">Examples<span><a href="#label-Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-comment"># Create a Reader for the AsciiDoc lines and retrieve the next block from it.</span>
<span class="ruby-comment"># Lexer::next_block requires a parent, so we begin by instantiating an empty Document.</span>

<span class="ruby-identifier">doc</span> = <span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">lines</span>
<span class="ruby-identifier">block</span> = <span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">doc</span>)
<span class="ruby-identifier">block</span>.<span class="ruby-identifier">class</span>
<span class="ruby-comment"># =&gt; Asciidoctor::Block</span>
</pre>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="BlockMatchData">BlockMatchData
        
        <dd class="description">
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-build_block" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">build_block</span><span
            class="method-args">(block_context, content_model, terminator, parent, reader, attributes, options = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>whether a block supports complex content should be a config settingif
terminator is false, that means the all the lines in the reader should be
parsedNOTE could invoke filter in here, before and after parsing</p>
          
          

          
          <div class="method-source-code" id="build_block-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 875</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-identifier">content_model</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">content_model</span> <span class="ruby-operator">==</span> <span class="ruby-value">:skip</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">content_model</span> <span class="ruby-operator">==</span> <span class="ruby-value">:raw</span>
    <span class="ruby-identifier">skip_processing</span> = <span class="ruby-identifier">content_model</span> <span class="ruby-operator">==</span> <span class="ruby-value">:skip</span>
    <span class="ruby-identifier">parse_as_content_model</span> = <span class="ruby-value">:simple</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">skip_processing</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">parse_as_content_model</span> = <span class="ruby-identifier">content_model</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">terminator</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parse_as_content_model</span> <span class="ruby-operator">==</span> <span class="ruby-value">:verbatim</span>
      <span class="ruby-identifier">lines</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(<span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">content_model</span> = <span class="ruby-value">:simple</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">content_model</span> <span class="ruby-operator">==</span> <span class="ruby-value">:compound</span>
      <span class="ruby-identifier">lines</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(
          <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
          <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
          <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
          <span class="ruby-value">:skip_line_comments</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
          <span class="ruby-value">:skip_processing</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">skip_processing</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
        <span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:block_terminates_paragraph</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">line</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>]))
      }
      <span class="ruby-comment"># QUESTION check for empty lines after grabbing lines for simple content model?</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">block_reader</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">parse_as_content_model</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:compound</span>
    <span class="ruby-identifier">lines</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:chomp_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:skip_processing</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">skip_processing</span>)
    <span class="ruby-identifier">block_reader</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-comment"># terminator is false when reader has already been prepared</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">terminator</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">lines</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">block_reader</span> = <span class="ruby-identifier">reader</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">lines</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">cursor</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">cursor</span>
    <span class="ruby-identifier">block_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:skip_processing</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">skip_processing</span>), <span class="ruby-identifier">cursor</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">content_model</span> <span class="ruby-operator">==</span> <span class="ruby-value">:skip</span>
    <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">clear</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">lines</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">content_model</span> <span class="ruby-operator">==</span> <span class="ruby-value">:verbatim</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'indent'</span>)
    <span class="ruby-identifier">reset_block_indent!</span> <span class="ruby-identifier">lines</span>, <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'indent'</span>].<span class="ruby-identifier">to_i</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">processor</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:processor</span>])
    <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'style'</span>)
    <span class="ruby-identifier">processor</span>.<span class="ruby-identifier">options</span>[<span class="ruby-value">:content_model</span>] = <span class="ruby-identifier">content_model</span>
    <span class="ruby-identifier">block</span> = <span class="ruby-identifier">processor</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">block_reader</span> <span class="ruby-operator">||</span> <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">lines</span>), <span class="ruby-identifier">attributes</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">block_context</span>, <span class="ruby-value">:content_model</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">content_model</span>, <span class="ruby-value">:attributes</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>, <span class="ruby-value">:source</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">lines</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># should supports_caption be necessary?</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:supports_caption</span>, <span class="ruby-keyword">false</span>)
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'title'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'title'</span>)
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">assign_caption</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'caption'</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">content_model</span> <span class="ruby-operator">==</span> <span class="ruby-value">:compound</span>
    <span class="ruby-comment"># we can look for blocks until there are no more lines (and not worry</span>
    <span class="ruby-comment"># about sections) since the reader is confined within the boundaries of a</span>
    <span class="ruby-comment"># delimited block</span>
    <span class="ruby-identifier">parse_blocks</span> <span class="ruby-identifier">block_reader</span>, <span class="ruby-identifier">block</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- build_block-source -->
          
        </div>

        

        
      </div><!-- build_block-method -->

    
      <div id="method-c-is_single_line_section_title-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_single_line_section_title?</span><span
            class="method-args">(line1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="is_single_line_section_title-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1484</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_single_line_section_title?</span>(<span class="ruby-identifier">line1</span>)
  <span class="ruby-identifier">first_char</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">line1</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">first_char</span> <span class="ruby-operator">==</span> <span class="ruby-string">'='</span> <span class="ruby-operator">||</span> (<span class="ruby-constant">Compliance</span>.<span class="ruby-identifier">markdown_syntax</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">first_char</span> <span class="ruby-operator">==</span> <span class="ruby-string">'#'</span>)) <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_title</span>]))
    <span class="ruby-identifier">single_line_section_level</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_single_line_section_title-3F-source -->
          
        </div>

        

        
      </div><!-- is_single_line_section_title-3F-method -->

    
      <div id="method-c-is_two_line_section_title-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_two_line_section_title?</span><span
            class="method-args">(line1, line2)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="is_two_line_section_title-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1494</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_two_line_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line1</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line2</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">SECTION_LEVELS</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">line2</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_underline</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_name</span>]) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-comment"># chomp so that a (non-visible) endline does not impact calculation</span>
      (<span class="ruby-identifier">line_length</span>(<span class="ruby-identifier">line1</span>) <span class="ruby-operator">-</span> <span class="ruby-identifier">line_length</span>(<span class="ruby-identifier">line2</span>)).<span class="ruby-identifier">abs</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">section_level</span> <span class="ruby-identifier">line2</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_two_line_section_title-3F-source -->
          
        </div>

        

        
      </div><!-- is_two_line_section_title-3F-method -->

    
      <div id="method-c-process_attribute_entries" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process_attribute_entries</span><span
            class="method-args">(reader, parent, attributes = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="process_attribute_entries-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1857</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">process_attribute_entries</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_comment_lines</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">process_attribute_entry</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
    <span class="ruby-comment"># discard line just processed</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_comment_lines</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- process_attribute_entries-source -->
          
        </div>

        

        
      </div><!-- process_attribute_entries-method -->

    
      <div id="method-c-process_attribute_entry" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process_attribute_entry</span><span
            class="method-args">(reader, parent, attributes = nil, match = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="process_attribute_entry-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1866</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">process_attribute_entry</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">match</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">match</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_entry</span>]) <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span>
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
    <span class="ruby-identifier">value</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-string">''</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">end_with?</span> <span class="ruby-constant">LINE_BREAK</span>
      <span class="ruby-identifier">value</span>.<span class="ruby-identifier">chop!</span>.<span class="ruby-identifier">rstrip!</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
        <span class="ruby-identifier">next_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">strip</span>
        <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">end_with?</span> <span class="ruby-constant">LINE_BREAK</span>
          <span class="ruby-identifier">value</span> = <span class="ruby-node">&quot;#{value} #{next_line.chop.rstrip}&quot;</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">value</span> = <span class="ruby-node">&quot;#{value} #{next_line}&quot;</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">store_attribute</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>, <span class="ruby-identifier">attributes</span>)
    <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- process_attribute_entry-source -->
          
        </div>

        

        
      </div><!-- process_attribute_entry-method -->

    
      <div id="method-c-reset_block_indent-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">reset_block_indent!</span><span
            class="method-args">(lines, indent = 0)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Remove the indentation (block offset) shared by all the lines, thenindent
the lines by the specified amount if specified</p>

<p>Trim the leading whitespace (indentation) equivalent to the lengthof the
indent on the least indented line. If the indent argumentis specified,
indent the lines by this many spaces (columns).</p>

<p>The purpose of this method is to shift a block of text toalign to the left
margin, while still preserving the relativeindentation between lines</p>
<dl class="rdoc-list note-list"><dt>lines
<dd>
<p>the Array of String lines to process</p>
</dd><dt>indent
<dd>
<p>the integer number of spaces to add to the beginningof each line; if this
value is nil, the existingspace is preserved (optional, default: 0)</p>
</dd></dl>

<h3 id="method-c-reset_block_indent-21-label-Examples">Examples<span><a href="#method-c-reset_block_indent-21-label-Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">source</span> = <span class="ruby-value">&lt;&lt;EOS
    def names
      @name.split ' ')
    end
EOS</span>

<span class="ruby-identifier">source</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">entries</span>
<span class="ruby-comment"># =&gt; [&quot;    def names\n&quot;, &quot;      @names.split ' '\n&quot;, &quot;    end\n&quot;]</span>

<span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">reset_block_indent</span>(<span class="ruby-identifier">source</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">entries</span>)
<span class="ruby-comment"># =&gt; [&quot;def names\n&quot;, &quot;  @names.split ' '\n&quot;, &quot;end\n&quot;]</span>

<span class="ruby-identifier">puts</span> <span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">reset_block_indent</span>(<span class="ruby-identifier">source</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">entries</span>).<span class="ruby-identifier">join</span>
<span class="ruby-comment"># =&gt; def names</span>
<span class="ruby-comment"># =&gt;   @names.split ' '</span>
<span class="ruby-comment"># =&gt; end</span>
</pre>

<p>returns the Array of String lines with block offset removed</p>
          
          

          
          <div class="method-source-code" id="reset_block_indent-21-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2407</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reset_block_indent!</span>(<span class="ruby-identifier">lines</span>, <span class="ruby-identifier">indent</span> = <span class="ruby-value">0</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-identifier">tab_detected</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-comment"># TODO make tab size configurable</span>
  <span class="ruby-identifier">tab_expansion</span> = <span class="ruby-string">'    '</span>
  <span class="ruby-comment"># strip leading block indent</span>
  <span class="ruby-identifier">offsets</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># break if the first char is non-whitespace</span>
    <span class="ruby-keyword">break</span> [] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chomp</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>].<span class="ruby-identifier">lstrip</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">include?</span> <span class="ruby-string">&quot;\t&quot;</span>
      <span class="ruby-identifier">tab_detected</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">line</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-string">&quot;\t&quot;</span>, <span class="ruby-identifier">tab_expansion</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">flush_line</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">lstrip</span>).<span class="ruby-identifier">empty?</span>
      <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">offset</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">flush_line</span>.<span class="ruby-identifier">length</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
      <span class="ruby-keyword">break</span> []
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">offset</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">offsets</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">offsets</span> = <span class="ruby-identifier">offsets</span>.<span class="ruby-identifier">compact</span>).<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">offset</span> = <span class="ruby-identifier">offsets</span>.<span class="ruby-identifier">min</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-string">&quot;\t&quot;</span>, <span class="ruby-identifier">tab_expansion</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">tab_detected</span>
        <span class="ruby-identifier">line</span>[<span class="ruby-identifier">offset</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-operator">||</span> <span class="ruby-string">&quot;\n&quot;</span>
      }
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">indent</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">padding</span> = <span class="ruby-string">' '</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">indent</span>
    <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-node">%Q(#{padding}#{line})</span> }
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- reset_block_indent-21-source -->
          
        </div>

        

        
      </div><!-- reset_block_indent-21-method -->

    
      <div id="method-c-section_level" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">section_level</span><span
            class="method-args">(line)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Private: Get the Integer section level based on the charactersused in the
ASCII line under the section title.</p>
<dl class="rdoc-list note-list"><dt>line
<dd>
<p>the String line from under the section title.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="section_level-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1434</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">section_level</span>(<span class="ruby-identifier">line</span>)
  <span class="ruby-constant">SECTION_LEVELS</span>[<span class="ruby-identifier">line</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]]
<span class="ruby-keyword">end</span></pre>
          </div><!-- section_level-source -->
          
        </div>

        

        
      </div><!-- section_level-method -->

    
      <div id="method-c-single_line_section_level" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">single_line_section_level</span><span
            class="method-args">(marker)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="single_line_section_level-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1440</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">single_line_section_level</span>(<span class="ruby-identifier">marker</span>)
  <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- single_line_section_level-source -->
          
        </div>

        

        
      </div><!-- single_line_section_level-method -->

    
    </section><!-- public-class-method-details -->
  
  </section><!-- 5Buntitled-5D -->

  
  
  <section id="Public" class="documentation-section">
    
    <div class="documentation-section-title">
      <h2 class="section-header">
        Public
      </h2>
      <span class="section-click-top">
        <a href="#top">&uarr; top</a>
      </span>
    </div>
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-Public-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-is_delimited_block-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_delimited_block?</span><span
            class="method-args">(line, return_match_data = false)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Determines whether this line is the start of any of the delimited blocks</p>

<p>returns the match data if this line is the first line of a delimited block
or nil if not</p>
          
          

          
          <div class="method-source-code" id="is_delimited_block-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 822</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">return_match_data</span> = <span class="ruby-keyword">false</span>)
  <span class="ruby-identifier">line_len</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">length</span>
  <span class="ruby-comment"># optimized for best performance</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_len</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_len</span> <span class="ruby-operator">==</span> <span class="ruby-value">3</span>
      <span class="ruby-identifier">tip</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chop</span>
      <span class="ruby-identifier">tl</span> = <span class="ruby-value">2</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">tip</span> = <span class="ruby-identifier">line</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>]
      <span class="ruby-identifier">tl</span> = <span class="ruby-value">4</span>

      <span class="ruby-keyword">if</span> <span class="ruby-constant">Compliance</span>.<span class="ruby-identifier">markdown_syntax</span>
        <span class="ruby-comment"># special case for fenced code blocks</span>
        <span class="ruby-identifier">tip_alt</span> = <span class="ruby-identifier">tip</span>.<span class="ruby-identifier">chop</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">tip_alt</span> <span class="ruby-operator">==</span> <span class="ruby-string">'```'</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tip_alt</span> <span class="ruby-operator">==</span> <span class="ruby-string">'~~~'</span>
          <span class="ruby-identifier">tip</span> = <span class="ruby-identifier">tip_alt</span>
          <span class="ruby-identifier">tl</span> = <span class="ruby-value">3</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-constant">DELIMITED_BLOCKS</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-identifier">tip</span>
      <span class="ruby-comment"># if tip is the full line</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">tl</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">line_len</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
        <span class="ruby-comment">#return_match_data ? BlockMatchData.new(DELIMITED_BLOCKS[tip], tip, tip) : true</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">return_match_data</span>
          <span class="ruby-identifier">context</span>, <span class="ruby-identifier">masq</span> = <span class="ruby-operator">*</span><span class="ruby-constant">DELIMITED_BLOCKS</span>[<span class="ruby-identifier">tip</span>]
          <span class="ruby-constant">BlockMatchData</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">context</span>, <span class="ruby-identifier">masq</span>, <span class="ruby-identifier">tip</span>, <span class="ruby-identifier">tip</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:any_blk</span>])
        <span class="ruby-comment">#return_match_data ? BlockMatchData.new(DELIMITED_BLOCKS[tip], tip, match[0]) : true</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">return_match_data</span>
          <span class="ruby-identifier">context</span>, <span class="ruby-identifier">masq</span> = <span class="ruby-operator">*</span><span class="ruby-constant">DELIMITED_BLOCKS</span>[<span class="ruby-identifier">tip</span>]
          <span class="ruby-constant">BlockMatchData</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">context</span>, <span class="ruby-identifier">masq</span>, <span class="ruby-identifier">tip</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>])
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">nil</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_delimited_block-3F-source -->
          
        </div>

        

        
      </div><!-- is_delimited_block-3F-method -->

    
      <div id="method-c-is_section_title-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_section_title?</span><span
            class="method-args">(line1, line2 = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Checks if these lines are a section title</p>
<dl class="rdoc-list note-list"><dt>line1
<dd>
<p>the first line as a String</p>
</dd><dt>line2
<dd>
<p>the second line as a String (default: nil)</p>
</dd></dl>

<p>returns the section level if these lines are a section title,false
otherwise</p>
          
          

          
          <div class="method-source-code" id="is_section_title-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1474</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">level</span> = <span class="ruby-identifier">is_single_line_section_title?</span>(<span class="ruby-identifier">line1</span>))
    <span class="ruby-identifier">level</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">line2</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">level</span> = <span class="ruby-identifier">is_two_line_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span>))
    <span class="ruby-identifier">level</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_section_title-3F-source -->
          
        </div>

        

        
      </div><!-- is_section_title-3F-method -->

    
      <div id="method-c-line_length" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">line_length</span><span
            class="method-args">(line)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the number of unicode characters in the line, excluding the
endline</p>
<dl class="rdoc-list note-list"><dt>line
<dd>
<p>the String to calculate</p>
</dd></dl>

<p>returns the number of unicode characters in the line</p>
          
          

          
          <div class="method-source-code" id="line_length-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1589</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">line_length</span>(<span class="ruby-identifier">line</span>)
  <span class="ruby-constant">FORCE_UNICODE_LINE_LENGTH</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/./</span>).<span class="ruby-identifier">length</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">length</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- line_length-source -->
          
        </div>

        

        
      </div><!-- line_length-method -->

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Make sure the <a href="Lexer.html">Lexer</a> object doesnt get
initialized.</p>

<p>Raises RuntimeError if this constructor is invoked.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-string">'Au contraire, mon frere. No lexer instances will be running around.'</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
      <div id="method-c-next_block" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_block</span><span
            class="method-args">(reader, parent, attributes = {}, options = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return the next <a href="Section.html">Section</a> or <a
href="Block.html">Block</a> object from the <a
href="Reader.html">Reader</a>.</p>

<p>Begins by skipping over blank lines to find the start of the next Sectionor
<a href="Block.html">Block</a>. Processes each line of the reader in
sequence until a <a href="Section.html">Section</a> orBlock is found or the
reader has no more lines.</p>

<p>Uses regular expressions from the <a
href="../Asciidoctor.html">Asciidoctor</a> module to match Sectionand <a
href="Block.html">Block</a> delimiters. The ensuing lines are then
processed accordingto the type of content.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the next block</p>
</dd><dt>parent
<dd>
<p>The <a href="Document.html">Document</a>, <a
href="Section.html">Section</a> or <a href="Block.html">Block</a> to which
the next block belongs</p>
</dd></dl>

<p>Returns a <a href="Section.html">Section</a> or <a
href="Block.html">Block</a> object holding the parsed content of the
processed lines</p>
          
          

          
          <div class="method-source-code" id="next_block-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 322</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {}, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-comment"># Skip ahead to the block content</span>
  <span class="ruby-identifier">skipped</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-comment"># bail if we've reached the end of the parent block or document</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>

  <span class="ruby-identifier">text_only</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>]
  <span class="ruby-comment"># check for option to find list item text only</span>
  <span class="ruby-comment"># if skipped a line, assume a list continuation was</span>
  <span class="ruby-comment"># used and block content is acceptable</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">text_only</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">skipped</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:text</span>)
    <span class="ruby-identifier">text_only</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-identifier">parse_metadata</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:parse_metadata</span>, <span class="ruby-keyword">true</span>)
  <span class="ruby-comment">#parse_sections = options.fetch(:parse_sections, false)</span>

  <span class="ruby-identifier">document</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">extensions</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">extensions</span>)
    <span class="ruby-identifier">block_extensions</span> = <span class="ruby-identifier">extensions</span>.<span class="ruby-identifier">blocks?</span>
    <span class="ruby-identifier">macro_extensions</span> = <span class="ruby-identifier">extensions</span>.<span class="ruby-identifier">block_macros?</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">block_extensions</span> = <span class="ruby-identifier">macro_extensions</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment">#parent_context = parent.is_a?(Block) ? parent.context : nil</span>
  <span class="ruby-identifier">in_list</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">List</span>)
  <span class="ruby-identifier">block</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">style</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">explicit_style</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-comment"># if parsing metadata, read until there is no more to read</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parse_metadata</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span>)
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-comment">#elsif parse_sections &amp;&amp; parent_context.nil? &amp;&amp; is_next_line_section?(reader, attributes)</span>
    <span class="ruby-comment">#  block, attributes = next_section(reader, parent, attributes)</span>
    <span class="ruby-comment">#  break</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># QUESTION should we introduce a parsing context object?</span>
    <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_line</span>
    <span class="ruby-identifier">delimited_block</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">block_context</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">cloaked_context</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">terminator</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-comment"># QUESTION put this inside call to rekey attributes?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]
      <span class="ruby-identifier">style</span>, <span class="ruby-identifier">explicit_style</span> = <span class="ruby-identifier">parse_style_attribute</span>(<span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">reader</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">delimited_blk_match</span> = <span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-keyword">true</span>)
      <span class="ruby-identifier">delimited_block</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">cloaked_context</span> = <span class="ruby-identifier">delimited_blk_match</span>.<span class="ruby-identifier">context</span>
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">delimited_blk_match</span>.<span class="ruby-identifier">terminator</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">style</span>
        <span class="ruby-identifier">style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">block_context</span>.<span class="ruby-identifier">to_s</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">block_context</span>.<span class="ruby-identifier">to_s</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">delimited_blk_match</span>.<span class="ruby-identifier">masq</span>.<span class="ruby-identifier">include?</span> <span class="ruby-identifier">style</span>
          <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">to_sym</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk_match</span>.<span class="ruby-identifier">masq</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">'admonition'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">ADMONITION_STYLES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">style</span>)
          <span class="ruby-identifier">block_context</span> = <span class="ruby-value">:admonition</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">block_extensions</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">extensions</span>.<span class="ruby-identifier">processor_registered_for_block?</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">block_context</span>)
          <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">to_sym</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: WARNING: #{reader.prev_line_info}: invalid style for #{block_context} block: #{style}&quot;</span>
          <span class="ruby-identifier">style</span> = <span class="ruby-identifier">block_context</span>.<span class="ruby-identifier">to_s</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">delimited_block</span>

      <span class="ruby-comment"># this loop only executes once; used for flow control</span>
      <span class="ruby-comment"># break once a block is found or at end of loop</span>
      <span class="ruby-comment"># returns nil if the line must be dropped</span>
      <span class="ruby-comment"># Implementation note - while(true) is twice as fast as loop</span>
      <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>

        <span class="ruby-comment"># process lines verbatim</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">style</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:strict_verbatim_paragraphs</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">VERBATIM_STYLES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">style</span>)
          <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">to_sym</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-comment"># advance to block parsing =&gt;</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># process lines normally</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">text_only</span>
          <span class="ruby-identifier">first_char</span> = <span class="ruby-identifier">this_line</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]
          <span class="ruby-comment"># NOTE we're letting break lines (ruler, page_break, etc) have attributes</span>
          <span class="ruby-keyword">if</span> <span class="ruby-constant">BREAK_LINES</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">first_char</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span> <span class="ruby-operator">&amp;&amp;</span>
              (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">Compliance</span>.<span class="ruby-identifier">markdown_syntax</span> <span class="ruby-operator">?</span> <span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:break_line_plus</span>] <span class="ruby-operator">:</span> <span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:break_line</span>]))
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-constant">BREAK_LINES</span>[<span class="ruby-identifier">first_char</span>], <span class="ruby-value">:content_model</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:empty</span>)
            <span class="ruby-keyword">break</span>

          <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:media_blk_macro</span>]))
            <span class="ruby-identifier">blk_ctx</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_sym</span>
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">blk_ctx</span>, <span class="ruby-value">:content_model</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:empty</span>)
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:image</span>
              <span class="ruby-identifier">posattrs</span> = [<span class="ruby-string">'alt'</span>, <span class="ruby-string">'width'</span>, <span class="ruby-string">'height'</span>]
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:video</span>
              <span class="ruby-identifier">posattrs</span> = [<span class="ruby-string">'poster'</span>, <span class="ruby-string">'width'</span>, <span class="ruby-string">'height'</span>]
            <span class="ruby-keyword">else</span>
              <span class="ruby-identifier">posattrs</span> = []
            <span class="ruby-keyword">end</span>

            <span class="ruby-keyword">unless</span> <span class="ruby-identifier">style</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">explicit_style</span>
              <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'alt'</span>] = <span class="ruby-identifier">style</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:image</span>
              <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'style'</span>)
              <span class="ruby-identifier">style</span> = <span class="ruby-keyword">nil</span>
            <span class="ruby-keyword">end</span>

            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">parse_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>], <span class="ruby-identifier">posattrs</span>,
                <span class="ruby-value">:unescape_input</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:image</span>),
                <span class="ruby-value">:sub_input</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                <span class="ruby-value">:sub_result</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>,
                <span class="ruby-value">:into</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
            <span class="ruby-identifier">target</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">sub_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>], <span class="ruby-value">:attribute_missing</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'drop-line'</span>)
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">target</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-keyword">if</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-string">'attribute-missing'</span>, <span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:attribute_missing</span>]) <span class="ruby-operator">==</span> <span class="ruby-string">'skip'</span>
                <span class="ruby-comment"># retain as unparsed</span>
                <span class="ruby-keyword">return</span> <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:paragraph</span>, <span class="ruby-value">:source</span> =<span class="ruby-operator">&gt;</span> [<span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span>])
              <span class="ruby-keyword">else</span>
                <span class="ruby-comment"># drop the line if target resolves to nothing</span>
                <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
              <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">end</span>

            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'target'</span>] = <span class="ruby-identifier">target</span>
            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'title'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'title'</span>)
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">blk_ctx</span> <span class="ruby-operator">==</span> <span class="ruby-value">:image</span>
              <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:images</span>, <span class="ruby-identifier">target</span>)
              <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'alt'</span>] <span class="ruby-operator">||=</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">basename</span>(<span class="ruby-identifier">target</span>, <span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-identifier">target</span>)).<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_-'</span>, <span class="ruby-string">' '</span>)
              <span class="ruby-comment"># QUESTION should video or audio have an auto-numbered caption?</span>
              <span class="ruby-identifier">block</span>.<span class="ruby-identifier">assign_caption</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'caption'</span>), <span class="ruby-string">'figure'</span>
            <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">break</span>

          <span class="ruby-comment"># NOTE we're letting the toc macro have attributes</span>
          <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:toc</span>]))
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:toc</span>, <span class="ruby-value">:content_model</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:empty</span>)
            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">parse_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>], [], <span class="ruby-value">:sub_result</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>, <span class="ruby-value">:into</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
            <span class="ruby-keyword">break</span>

          <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">macro_extensions</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:generic_blk_macro</span>])) <span class="ruby-operator">&amp;&amp;</span>
              <span class="ruby-identifier">extensions</span>.<span class="ruby-identifier">processor_registered_for_block_macro?</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>])
            <span class="ruby-identifier">name</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
            <span class="ruby-identifier">target</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]
            <span class="ruby-identifier">raw_attributes</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>]
            <span class="ruby-identifier">processor</span> = <span class="ruby-identifier">extensions</span>.<span class="ruby-identifier">load_block_macro_processor</span> <span class="ruby-identifier">name</span>, <span class="ruby-identifier">document</span>
            <span class="ruby-keyword">unless</span> <span class="ruby-identifier">raw_attributes</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-identifier">document</span>.<span class="ruby-identifier">parse_attributes</span>(<span class="ruby-identifier">raw_attributes</span>, <span class="ruby-identifier">processor</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:pos_attrs</span>, []),
                  <span class="ruby-value">:sub_input</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:sub_result</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>, <span class="ruby-value">:into</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
            <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">default_attrs</span> = <span class="ruby-identifier">processor</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:default_attrs</span>, {})).<span class="ruby-identifier">empty?</span>
              <span class="ruby-identifier">default_attrs</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">k</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">v</span> }
            <span class="ruby-keyword">end</span>
            <span class="ruby-identifier">block</span> = <span class="ruby-identifier">processor</span>.<span class="ruby-identifier">process</span> <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">target</span>, <span class="ruby-identifier">attributes</span>
            <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-keyword">break</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># haven't found anything yet, continue</span>
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:colist</span>]))
          <span class="ruby-identifier">block</span> = <span class="ruby-constant">List</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:colist</span>)
          <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'arabic'</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">expected_index</span> = <span class="ruby-value">1</span>
          <span class="ruby-keyword">begin</span>
            <span class="ruby-comment"># might want to move this check to a validate method</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">expected_index</span>
              <span class="ruby-comment"># FIXME this lineno - 2 hack means we need a proper look-behind cursor</span>
              <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: WARNING: #{reader.path}: line #{reader.lineno - 2}: callout list item index: expected #{expected_index} got #{match[1]}&quot;</span>
            <span class="ruby-keyword">end</span>
            <span class="ruby-identifier">list_item</span> = <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">match</span>)
            <span class="ruby-identifier">expected_index</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
            <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">nil?</span>
              <span class="ruby-identifier">block</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">list_item</span>
              <span class="ruby-identifier">coids</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">callout_ids</span>(<span class="ruby-identifier">block</span>.<span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span>)
              <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">coids</span>.<span class="ruby-identifier">empty?</span>
                <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'coids'</span>] = <span class="ruby-identifier">coids</span>
              <span class="ruby-keyword">else</span>
                <span class="ruby-comment"># FIXME this lineno - 2 hack means we need a proper look-behind cursor</span>
                <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: WARNING: #{reader.path}: line #{reader.lineno - 2}: no callouts refer to list item #{block.items.size}&quot;</span>
              <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:colist</span>])

          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">next_list</span>
          <span class="ruby-keyword">break</span>

        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:ulist</span>]))
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-value">:ulist</span>, <span class="ruby-identifier">parent</span>)
          <span class="ruby-keyword">break</span>

        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:olist</span>]))
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-value">:olist</span>, <span class="ruby-identifier">parent</span>)
          <span class="ruby-comment"># QUESTION move this logic to next_outline_list?</span>
          <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>]
            <span class="ruby-identifier">marker</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">items</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'.'</span>
              <span class="ruby-comment"># first one makes more sense, but second one is AsciiDoc-compliant</span>
              <span class="ruby-comment">#attributes['style'] = (ORDERED_LIST_STYLES[block.level - 1] || ORDERED_LIST_STYLES.first).to_s</span>
              <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = (<span class="ruby-constant">ORDERED_LIST_STYLES</span>[<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">first</span>).<span class="ruby-identifier">to_s</span>
            <span class="ruby-keyword">else</span>
              <span class="ruby-identifier">style</span> = <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">detect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">ORDERED_LIST_MARKER_PATTERNS</span>[<span class="ruby-identifier">s</span>]) }
              <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = (<span class="ruby-identifier">style</span> <span class="ruby-operator">||</span> <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">first</span>).<span class="ruby-identifier">to_s</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">break</span>

        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dlist</span>]))
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_labeled_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">parent</span>)
          <span class="ruby-keyword">break</span>

        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">style</span> <span class="ruby-operator">==</span> <span class="ruby-string">'float'</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">==</span> <span class="ruby-string">'discrete'</span>) <span class="ruby-operator">&amp;&amp;</span>
            <span class="ruby-identifier">is_section_title?</span>(<span class="ruby-identifier">this_line</span>, (<span class="ruby-constant">Compliance</span>.<span class="ruby-identifier">underline_style_section_titles</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>(<span class="ruby-keyword">true</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>))
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">float_id</span>, <span class="ruby-identifier">float_title</span>, <span class="ruby-identifier">float_level</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
          <span class="ruby-identifier">float_id</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'id'</span>)
          <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:floating_title</span>, <span class="ruby-value">:content_model</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:empty</span>)
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">float_id</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">float_id</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-comment"># FIXME remove hack of creating throwaway Section to get at the generate_id method</span>
            <span class="ruby-identifier">tmp_sect</span> = <span class="ruby-constant">Section</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>)
            <span class="ruby-identifier">tmp_sect</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">float_title</span>
            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">tmp_sect</span>.<span class="ruby-identifier">generate_id</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">float_id</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">float_title</span>]) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>
          <span class="ruby-identifier">block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">float_level</span>
          <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">float_title</span>
          <span class="ruby-keyword">break</span>

        <span class="ruby-comment"># FIXME create another set for &quot;passthrough&quot; styles</span>
        <span class="ruby-comment"># FIXME make this more DRY!</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">style</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'normal'</span>
          <span class="ruby-keyword">if</span> <span class="ruby-constant">PARAGRAPH_STYLES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">style</span>)
            <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">to_sym</span>
            <span class="ruby-identifier">cloaked_context</span> = <span class="ruby-value">:paragraph</span>
            <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
            <span class="ruby-comment"># advance to block parsing =&gt;</span>
            <span class="ruby-keyword">break</span>
          <span class="ruby-keyword">elsif</span> <span class="ruby-constant">ADMONITION_STYLES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">style</span>)
            <span class="ruby-identifier">block_context</span> = <span class="ruby-value">:admonition</span>
            <span class="ruby-identifier">cloaked_context</span> = <span class="ruby-value">:paragraph</span>
            <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
            <span class="ruby-comment"># advance to block parsing =&gt;</span>
            <span class="ruby-keyword">break</span>
          <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">block_extensions</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">extensions</span>.<span class="ruby-identifier">processor_registered_for_block?</span>(<span class="ruby-identifier">style</span>, <span class="ruby-value">:paragraph</span>)
            <span class="ruby-identifier">block_context</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">to_sym</span>
            <span class="ruby-identifier">cloaked_context</span> = <span class="ruby-value">:paragraph</span>
            <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
            <span class="ruby-comment"># advance to block parsing =&gt;</span>
            <span class="ruby-keyword">break</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: WARNING: #{reader.prev_line_info}: invalid style for paragraph: #{style}&quot;</span>
            <span class="ruby-identifier">style</span> = <span class="ruby-keyword">nil</span>
            <span class="ruby-comment"># continue to process paragraph</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">break_at_list</span> = (<span class="ruby-identifier">skipped</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">in_list</span>)

        <span class="ruby-comment"># a literal paragraph is contiguous lines starting at least one space</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'normal'</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
          <span class="ruby-comment"># So we need to actually include this one in the read_lines group</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">lines</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(
              <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
            <span class="ruby-comment"># a preceding blank line (skipped &gt; 0) indicates we are in a list continuation</span>
            <span class="ruby-comment"># and therefore we should not break at a list item</span>
            <span class="ruby-comment"># (this won't stop breaking on item of same level since we've already parsed them out)</span>
            <span class="ruby-comment"># QUESTION can we turn this block into a lambda or function call?</span>
            (<span class="ruby-identifier">break_at_list</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:any_list</span>])) <span class="ruby-operator">||</span>
            (<span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:block_terminates_paragraph</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">line</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>])))
          }

          <span class="ruby-identifier">reset_block_indent!</span> <span class="ruby-identifier">lines</span>

          <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:literal</span>, <span class="ruby-value">:content_model</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:verbatim</span>, <span class="ruby-value">:source</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">lines</span>, <span class="ruby-value">:attributes</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
          <span class="ruby-comment"># a literal gets special meaning inside of a definition list</span>
          <span class="ruby-comment"># TODO this feels hacky, better way to distinguish from explicit literal block?</span>
          <span class="ruby-identifier">block</span>.<span class="ruby-identifier">set_option</span>(<span class="ruby-string">'listparagraph'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">in_list</span>

        <span class="ruby-comment"># a paragraph is contiguous nonblank/noncontinuation lines</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">lines</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(
              <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:skip_line_comments</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
            <span class="ruby-comment"># a preceding blank line (skipped &gt; 0) indicates we are in a list continuation</span>
            <span class="ruby-comment"># and therefore we should not break at a list item</span>
            <span class="ruby-comment"># (this won't stop breaking on item of same level since we've already parsed them out)</span>
            <span class="ruby-comment"># QUESTION can we turn this block into a lambda or function call?</span>
            (<span class="ruby-identifier">break_at_list</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:any_list</span>])) <span class="ruby-operator">||</span>
            (<span class="ruby-constant">COMPLIANCE</span>[<span class="ruby-value">:block_terminates_paragraph</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">line</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>])))
          }

          <span class="ruby-comment"># NOTE we need this logic because we've asked the reader to skip</span>
          <span class="ruby-comment"># line comments, which may leave us w/ an empty buffer if those</span>
          <span class="ruby-comment"># were the only lines found</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-comment"># call advance since the reader preserved the last line</span>
            <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
            <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
          <span class="ruby-keyword">end</span>

          <span class="ruby-identifier">catalog_inline_anchors</span>(<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">join</span>, <span class="ruby-identifier">document</span>)

          <span class="ruby-identifier">first_line</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">first</span>
          <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">text_only</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">admonition_match</span> = <span class="ruby-identifier">first_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:admonition_inline</span>]))
            <span class="ruby-identifier">lines</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">admonition_match</span>.<span class="ruby-identifier">post_match</span>.<span class="ruby-identifier">lstrip</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">admonition_match</span>[<span class="ruby-value">1</span>]
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'name'</span>] = <span class="ruby-identifier">admonition_name</span> = <span class="ruby-identifier">admonition_match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">downcase</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-node">&quot;#{admonition_name}-caption&quot;</span>]
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:admonition</span>, <span class="ruby-value">:source</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">lines</span>, <span class="ruby-value">:attributes</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
          <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">text_only</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Compliance</span>.<span class="ruby-identifier">markdown_syntax</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">first_line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'&gt; '</span>)
            <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
              <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'&gt; '</span>)
                <span class="ruby-identifier">line</span>[<span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
              <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-string">'&gt;'</span>
                <span class="ruby-identifier">line</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
              <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">line</span>
              <span class="ruby-keyword">end</span>
            }

            <span class="ruby-keyword">if</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'-- '</span>)
              <span class="ruby-identifier">attribution</span>, <span class="ruby-identifier">citetitle</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">pop</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">', '</span>, <span class="ruby-value">2</span>)
              <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-identifier">lines</span>[<span class="ruby-value">-1</span>] = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>
            <span class="ruby-keyword">else</span>
              <span class="ruby-identifier">attribution</span>, <span class="ruby-identifier">citetitle</span> = <span class="ruby-keyword">nil</span>
            <span class="ruby-keyword">end</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'quote'</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'attribution'</span>] = <span class="ruby-identifier">attribution</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">attribution</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'citetitle'</span>] = <span class="ruby-identifier">citetitle</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">citetitle</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-comment"># NOTE will only detect headings that are floating titles (not section titles)</span>
            <span class="ruby-comment"># TODO could assume a floating title when inside a block context</span>
            <span class="ruby-comment"># FIXME Reader needs to be created w/ line info</span>
            <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-value">:quote</span>, <span class="ruby-value">:compound</span>, <span class="ruby-keyword">false</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">lines</span>), <span class="ruby-identifier">attributes</span>)
          <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">text_only</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">first_line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'&quot;'</span>) <span class="ruby-operator">&amp;&amp;</span>
              <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'-- '</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">lines</span>[<span class="ruby-value">-2</span>].<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">'&quot;'</span>)
            <span class="ruby-identifier">lines</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">first_line</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
            <span class="ruby-identifier">attribution</span>, <span class="ruby-identifier">citetitle</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">pop</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">', '</span>, <span class="ruby-value">2</span>)
            <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-identifier">lines</span>[<span class="ruby-value">-1</span>] = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">chop</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'quote'</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'attribution'</span>] = <span class="ruby-identifier">attribution</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">attribution</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'citetitle'</span>] = <span class="ruby-identifier">citetitle</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">citetitle</span>.<span class="ruby-identifier">nil?</span>
            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:quote</span>, <span class="ruby-value">:source</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">lines</span>, <span class="ruby-value">:attributes</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
            <span class="ruby-comment">#block = Block.new(parent, :quote, :content_model =&gt; :compound, :attributes =&gt; attributes)</span>
            <span class="ruby-comment">#block &lt;&lt; Block.new(block, :paragraph, :source =&gt; lines)</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-comment"># if [normal] is used over an indented paragraph, unindent it</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">style</span> <span class="ruby-operator">==</span> <span class="ruby-string">'normal'</span> <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">first_char</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">first</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]) <span class="ruby-operator">==</span> <span class="ruby-string">' '</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">first_char</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\t&quot;</span>)
              <span class="ruby-identifier">first_line</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">first</span>
              <span class="ruby-identifier">first_line_shifted</span> = <span class="ruby-identifier">first_line</span>.<span class="ruby-identifier">lstrip</span>
              <span class="ruby-identifier">indent</span> = <span class="ruby-identifier">line_length</span>(<span class="ruby-identifier">first_line</span>) <span class="ruby-operator">-</span> <span class="ruby-identifier">line_length</span>(<span class="ruby-identifier">first_line_shifted</span>)
              <span class="ruby-identifier">lines</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">first_line_shifted</span>
              <span class="ruby-comment"># QUESTION should we fix the rest of the lines, since in XML output it's insignificant?</span>
              <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">size</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">lines</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">lines</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">lstrip</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
              <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">end</span>

            <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:paragraph</span>, <span class="ruby-value">:source</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">lines</span>, <span class="ruby-value">:attributes</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># forbid loop from executing more than once</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># either delimited block or styled paragraph</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block_context</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-comment"># abstract and partintro should be handled by open block</span>
      <span class="ruby-comment"># FIXME kind of hackish...need to sort out how to generalize this</span>
      <span class="ruby-identifier">block_context</span> = <span class="ruby-value">:open</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:abstract</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:partintro</span>

      <span class="ruby-keyword">case</span> <span class="ruby-identifier">block_context</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:admonition</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'name'</span>] = <span class="ruby-identifier">admonition_name</span> = <span class="ruby-identifier">style</span>.<span class="ruby-identifier">downcase</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-node">&quot;#{admonition_name}-caption&quot;</span>]
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:compound</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">when</span> <span class="ruby-value">:comment</span>
        <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:skip</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>

      <span class="ruby-keyword">when</span> <span class="ruby-value">:example</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:compound</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>, {<span class="ruby-value">:supports_caption</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>})

      <span class="ruby-keyword">when</span> <span class="ruby-value">:listing</span>, <span class="ruby-value">:fenced_code</span>, <span class="ruby-value">:source</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:fenced_code</span>
          <span class="ruby-identifier">style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'source'</span>
          <span class="ruby-identifier">lang</span> = <span class="ruby-identifier">this_line</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">strip</span>
          <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'language'</span>] = <span class="ruby-identifier">lang</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">lang</span>.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">terminator</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">terminator</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:source</span>
          <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-keyword">nil</span>, <span class="ruby-string">'language'</span>, <span class="ruby-string">'linenums'</span>])
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-value">:listing</span>, <span class="ruby-value">:verbatim</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>, {<span class="ruby-value">:supports_caption</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>})

      <span class="ruby-keyword">when</span> <span class="ruby-value">:literal</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:verbatim</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
      
      <span class="ruby-keyword">when</span> <span class="ruby-value">:pass</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:raw</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">when</span> <span class="ruby-value">:open</span>, <span class="ruby-value">:sidebar</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-value">:compound</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">when</span> <span class="ruby-value">:table</span>
        <span class="ruby-identifier">cursor</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">cursor</span>
        <span class="ruby-identifier">block_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:skip_line_comments</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>), <span class="ruby-identifier">cursor</span>
        <span class="ruby-keyword">case</span> <span class="ruby-identifier">terminator</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]
          <span class="ruby-keyword">when</span> <span class="ruby-string">','</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'format'</span>] = <span class="ruby-string">'csv'</span>
          <span class="ruby-keyword">when</span> <span class="ruby-string">':'</span>
            <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'format'</span>] = <span class="ruby-string">'dsv'</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_table</span>(<span class="ruby-identifier">block_reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">when</span> <span class="ruby-value">:quote</span>, <span class="ruby-value">:verse</span>
        <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-keyword">nil</span>, <span class="ruby-string">'attribution'</span>, <span class="ruby-string">'citetitle'</span>])
        <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, (<span class="ruby-identifier">block_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:verse</span> <span class="ruby-operator">?</span> <span class="ruby-value">:verbatim</span> <span class="ruby-operator">:</span> <span class="ruby-value">:compound</span>), <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)

      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_extensions</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">extensions</span>.<span class="ruby-identifier">processor_registered_for_block?</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-identifier">cloaked_context</span>)
          <span class="ruby-identifier">processor</span> = <span class="ruby-identifier">extensions</span>.<span class="ruby-identifier">load_block_processor</span> <span class="ruby-identifier">block_context</span>, <span class="ruby-identifier">document</span>
          
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">content_model</span> = <span class="ruby-identifier">processor</span>.<span class="ruby-identifier">options</span>[<span class="ruby-value">:content_model</span>]) <span class="ruby-operator">!=</span> <span class="ruby-value">:skip</span>
            <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">pos_attrs</span> = <span class="ruby-identifier">processor</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:pos_attrs</span>, [])).<span class="ruby-identifier">empty?</span>
              <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-keyword">nil</span>].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">pos_attrs</span>))
            <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">default_attrs</span> = <span class="ruby-identifier">processor</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:default_attrs</span>, {})).<span class="ruby-identifier">empty?</span>
              <span class="ruby-identifier">default_attrs</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">k</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">v</span> }
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">block</span> = <span class="ruby-identifier">build_block</span>(<span class="ruby-identifier">block_context</span>, <span class="ruby-identifier">content_model</span>, <span class="ruby-identifier">terminator</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-value">:processor</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">processor</span>)
          <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-comment"># this should only happen if there's a misconfiguration</span>
          <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Unsupported block type #{block_context} at #{reader.line_info}&quot;</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># when looking for nested content, one or more line comments, comment</span>
  <span class="ruby-comment"># blocks or trailing attribute lists could leave us without a block,</span>
  <span class="ruby-comment"># so handle accordingly</span>
  <span class="ruby-comment"># REVIEW we may no longer need this nil check</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-comment"># REVIEW seems like there is a better way to organize this wrap-up</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>      <span class="ruby-operator">||=</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'id'</span>)
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span>     = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">caption</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'caption'</span>)
    <span class="ruby-comment"># TODO eventualy remove the style attribute from the attributes hash</span>
    <span class="ruby-comment">#block.style     = attributes.delete('style')</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">style</span>     = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>]
    <span class="ruby-comment"># AsciiDoc always use [id] as the reftext in HTML output,</span>
    <span class="ruby-comment"># but I'd like to do better in Asciidoctor</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'reftext'</span>)
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span>])
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">update_attributes</span>(<span class="ruby-identifier">attributes</span>)

    <span class="ruby-comment">#if document.attributes.has_key? :pending_attribute_entries</span>
    <span class="ruby-comment">#  document.attributes.delete(:pending_attribute_entries).each do |entry|</span>
    <span class="ruby-comment">#    entry.save_to block.attributes</span>
    <span class="ruby-comment">#  end</span>
    <span class="ruby-comment">#end</span>

    <span class="ruby-comment"># FIXME callout capabilities should be a setting on the block</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:listing</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:literal</span>
      <span class="ruby-identifier">catalog_callouts</span>(<span class="ruby-identifier">block</span>.<span class="ruby-identifier">source</span>, <span class="ruby-identifier">document</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_block-source -->
          
        </div>

        

        
      </div><!-- next_block-method -->

    
      <div id="method-c-next_section" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_section</span><span
            class="method-args">(reader, parent, attributes = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return the next section from the <a href="Reader.html">Reader</a>.</p>

<p>This method process block metadata, content and subsections for thissection
and returns the <a href="Section.html">Section</a> object and any orphaned
attributes.</p>

<p>If the parent is a <a href="Document.html">Document</a> and has a header
(document title), thenthis method will put any non-section blocks at the
start of documentinto a preamble <a href="Block.html">Block</a>. If there
are no such blocks, the preamble isdropped.</p>

<p>Since we are reading line-by-line, theres a chance that metadatathat
should be associated with the following block gets consumed.To deal with
this case, the method returns a running Hash oforphaned attributes that
get passed to the next <a href="Section.html">Section</a> or <a
href="Block.html">Block</a>.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source <a href="Reader.html">Reader</a></p>
</dd><dt>parent
<dd>
<p>the parent <a href="Section.html">Section</a> or <a
href="Document.html">Document</a> of this new section</p>
</dd><dt>attributes
<dd>
<p>a Hash of metadata that was left orphaned from theprevious <a
href="Section.html">Section</a>.</p>
</dd></dl>

<h3 id="method-c-next_section-label-Examples">Examples<span><a href="#method-c-next_section-label-Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">source</span>
<span class="ruby-comment"># =&gt; &quot;Greetings\n---------\nThis is my doc.\n\nSalutations\n-----------\nIt is awesome.&quot;</span>

<span class="ruby-identifier">reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">source</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">entries</span>
<span class="ruby-comment"># create empty document to parent the section</span>
<span class="ruby-comment"># and hold attributes extracted from header</span>
<span class="ruby-identifier">doc</span> = <span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>

<span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">doc</span>).<span class="ruby-identifier">first</span>.<span class="ruby-identifier">title</span>
<span class="ruby-comment"># =&gt; &quot;Greetings&quot;</span>

<span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">doc</span>).<span class="ruby-identifier">first</span>.<span class="ruby-identifier">title</span>
<span class="ruby-comment"># =&gt; &quot;Salutations&quot;</span>
</pre>

<p>returns a two-element Array containing the <a
href="Section.html">Section</a> and Hash of orphaned attributes</p>
          
          

          
          <div class="method-source-code" id="next_section-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 201</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {})
  <span class="ruby-identifier">preamble</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-comment"># FIXME if attributes[1] is a verbatim style, then don't check for section</span>

  <span class="ruby-comment"># check if we are at the start of processing the document</span>
  <span class="ruby-comment"># NOTE we could drop a hint in the attributes to indicate</span>
  <span class="ruby-comment"># that we are at a section title (so we don't have to check)</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Document</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">blocks</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">has_header?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'invalid-header'</span>) <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>))

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">has_header?</span>
      <span class="ruby-identifier">preamble</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:preamble</span>, <span class="ruby-value">:content_model</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:compound</span>)
      <span class="ruby-identifier">parent</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">preamble</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">section</span> = <span class="ruby-identifier">parent</span>

    <span class="ruby-identifier">current_level</span> = <span class="ruby-value">0</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'fragment'</span>
      <span class="ruby-identifier">expected_next_levels</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-comment"># small tweak to allow subsequent level-0 sections for book doctype</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'book'</span>
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">section</span> = <span class="ruby-identifier">initialize_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
    <span class="ruby-comment"># clear attributes, except for title which carries over</span>
    <span class="ruby-comment"># section title to next block of content</span>
    <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'title'</span>}
    <span class="ruby-identifier">current_level</span> = <span class="ruby-identifier">section</span>.<span class="ruby-identifier">level</span>
    <span class="ruby-comment"># subsections in preface &amp; appendix in multipart books start at level 2</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">current_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">special</span> <span class="ruby-operator">&amp;&amp;</span>
        <span class="ruby-identifier">section</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'book'</span> <span class="ruby-operator">&amp;&amp;</span> [<span class="ruby-string">'preface'</span>, <span class="ruby-string">'appendix'</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span>)
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-identifier">current_level</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-identifier">current_level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-comment"># Parse lines belonging to this section and its subsections until we</span>
  <span class="ruby-comment"># reach the end of this section level</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># 1. first look for metadata thingies (anchor, attribute list, block title line, etc)</span>
  <span class="ruby-comment"># 2. then look for a section, recurse if found</span>
  <span class="ruby-comment"># 3. then process blocks</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># We have to parse all the metadata lines before continuing with the loop,</span>
  <span class="ruby-comment"># otherwise subsequent metadata lines get interpreted as block content</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">section</span>, <span class="ruby-identifier">attributes</span>)

    <span class="ruby-identifier">next_level</span> = <span class="ruby-identifier">is_next_line_section?</span> <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span>
      <span class="ruby-identifier">next_level</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">attr</span>(<span class="ruby-string">'leveloffset'</span>, <span class="ruby-value">0</span>).<span class="ruby-identifier">to_i</span>
      <span class="ruby-identifier">doctype</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">current_level</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">section</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Document</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">doctype</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'book'</span>
          <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: ERROR: #{reader.line_info}: only book doctypes can contain level 0 sections&quot;</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">expected_next_levels</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">expected_next_levels</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">next_level</span>)
          <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: WARNING: #{reader.line_info}: section title out of sequence: &quot;</span> <span class="ruby-operator">+</span>
              <span class="ruby-node">&quot;expected #{expected_next_levels.size &gt; 1 ? 'levels' : 'level'} #{expected_next_levels * ' or '}, &quot;</span> <span class="ruby-operator">+</span>
              <span class="ruby-node">&quot;got level #{next_level}&quot;</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment"># the attributes returned are those that are orphaned</span>
        <span class="ruby-identifier">new_section</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">section</span>, <span class="ruby-identifier">attributes</span>)
        <span class="ruby-identifier">section</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_section</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">doctype</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'book'</span>
          <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: ERROR: #{reader.line_info}: only book doctypes can contain level 0 sections&quot;</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment"># close this section (and break out of the nesting) to begin a new one</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># just take one block or else we run the risk of overrunning section boundaries</span>
      <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, (<span class="ruby-identifier">preamble</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">section</span>), <span class="ruby-identifier">attributes</span>, <span class="ruby-value">:parse_metadata</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
        (<span class="ruby-identifier">preamble</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">section</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span>
        <span class="ruby-identifier">attributes</span> = {}
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># don't clear attributes if we don't find a block because they may</span>
        <span class="ruby-comment"># be trailing attributes that didn't get associated with a block</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">preamble</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">preamble</span>.<span class="ruby-identifier">blocks?</span>
    <span class="ruby-comment"># drop the preamble if it has no content</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">blocks</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">0</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># The attributes returned here are orphaned attributes that fall at the end</span>
  <span class="ruby-comment"># of a section that need to get transfered to the next section</span>
  <span class="ruby-comment"># see &quot;trailing block attributes transfer to the following section&quot; in</span>
  <span class="ruby-comment"># test/attributes_test.rb for an example</span>
  [<span class="ruby-identifier">section</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">parent</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">section</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">dup</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_section-source -->
          
        </div>

        

        
      </div><!-- next_section-method -->

    
      <div id="method-c-parse" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse</span><span
            class="method-args">(reader, document, options = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parses AsciiDoc source read from the <a href="Reader.html">Reader</a> into
the <a href="Document.html">Document</a></p>

<p>This method is the main entry-point into the <a href="Lexer.html">Lexer</a>
when parsing a full document.It first looks for and, if found, processes
the document title. It thenproceeds to iterate through the lines in the <a
href="Reader.html">Reader</a>, parsing the documentinto nested Sections and
Blocks.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the <a href="Reader.html">Reader</a> holding the source lines of the
document</p>
</dd><dt>document
<dd>
<p>the empty <a href="Document.html">Document</a> into which the lines will be
parsed</p>
</dd><dt>options
<dd>
<p>a Hash of options to control processing</p>
</dd></dl>

<p>returns the <a href="Document.html">Document</a> object</p>
          
          

          
          <div class="method-source-code" id="parse-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 47</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">block_attributes</span> = <span class="ruby-identifier">parse_document_header</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:header_only</span>]
    <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
      <span class="ruby-identifier">new_section</span>, <span class="ruby-identifier">block_attributes</span> = <span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, <span class="ruby-identifier">block_attributes</span>)
      <span class="ruby-identifier">document</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_section</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_section</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">document</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse-source -->
          
        </div>

        

        
      </div><!-- parse-method -->

    
      <div id="method-c-parse_blocks" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_blocks</span><span
            class="method-args">(reader, parent)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse blocks from this reader until there are no more lines.</p>

<p>This method calls Lexer#next_block until there are no more lines in
theReader. It does not consider sections because its assumed the <a
href="Reader.html">Reader</a> onlyhas lines which are within a delimited
block region.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> containing the lines to process</p>
</dd><dt>parent
<dd>
<p>The parent <a href="Block.html">Block</a> to which to attach the parsed
blocks</p>
</dd></dl>

<p>Returns nothing.</p>
          
          

          
          <div class="method-source-code" id="parse_blocks-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 955</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_blocks</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>)
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">block</span> = <span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>)
    <span class="ruby-identifier">parent</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_blocks-source -->
          
        </div>

        

        
      </div><!-- parse_blocks-method -->

    
      <div id="method-c-parse_document_header" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_document_header</span><span
            class="method-args">(reader, document)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parses the document header of the AsciiDoc source read from the <a
href="Reader.html">Reader</a></p>

<p>Reads the AsciiDoc source from the <a href="Reader.html">Reader</a> until
the end of the documentheader is reached. The <a
href="Document.html">Document</a> object is populated with information
fromthe header (document title, document attributes, etc). The
documentattributes are then saved to establish a save point to which to
rollbackafter parsing is complete.</p>

<p>This method assumes that there are no blank lines at the start of the
document,which are automatically removed by the reader.</p>

<p>returns the Hash of orphan block attributes captured above the header</p>
          
          

          
          <div class="method-source-code" id="parse_document_header-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 72</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_document_header</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-comment"># capture any lines of block-level metadata and plow away any comment lines</span>
  <span class="ruby-comment"># that precede first block</span>
  <span class="ruby-identifier">block_attributes</span> = <span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

  <span class="ruby-comment"># special case, block title is not allowed above document title,</span>
  <span class="ruby-comment"># carry attributes over to the document body</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'title'</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">finalize_header</span> <span class="ruby-identifier">block_attributes</span>, <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># yep, document title logic in AsciiDoc is just insanity</span>
  <span class="ruby-comment"># definitely an area for spec refinement</span>
  <span class="ruby-identifier">assigned_doctitle</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">val</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-string">'doctitle'</span>, <span class="ruby-string">''</span>)).<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">val</span>
    <span class="ruby-identifier">assigned_doctitle</span> = <span class="ruby-identifier">val</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">section_title</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-comment"># check if the first line is the document title</span>
  <span class="ruby-comment"># if so, add a header to the document and parse the header metadata</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_next_line_document_title?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">block_attributes</span>)
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">doctitle</span>, <span class="ruby-identifier">_</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">assigned_doctitle</span>
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">doctitle</span>
      <span class="ruby-identifier">assigned_doctitle</span> = <span class="ruby-identifier">doctitle</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'doctitle'</span>] = <span class="ruby-identifier">section_title</span> = <span class="ruby-identifier">doctitle</span>
    <span class="ruby-comment"># QUESTION: should the id assignment on Document be encapsulated in the Document class?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">id</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">block_attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'id'</span>)
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">block_attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'id'</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">parse_header_metadata</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">val</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-string">'doctitle'</span>, <span class="ruby-string">''</span>)).<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">val</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">section_title</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">val</span>
    <span class="ruby-identifier">assigned_doctitle</span> = <span class="ruby-identifier">val</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># restore doctitle attribute to original assignment</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">assigned_doctitle</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'doctitle'</span>] = <span class="ruby-identifier">assigned_doctitle</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># parse title and consume name section of manpage document</span>
  <span class="ruby-identifier">parse_manpage_header</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'manpage'</span>
 
  <span class="ruby-comment"># NOTE block_attributes are the block-level attributes (not document attributes) that</span>
  <span class="ruby-comment"># precede the first line of content (document title, first section or first block)</span>
  <span class="ruby-identifier">document</span>.<span class="ruby-identifier">finalize_header</span> <span class="ruby-identifier">block_attributes</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_document_header-source -->
          
        </div>

        

        
      </div><!-- parse_document_header-method -->

    
      <div id="method-c-parse_header_metadata" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_header_metadata</span><span
            class="method-args">(reader, document = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Consume and parse the two header lines (line 1 = author info, line 2 =
revision info).</p>

<p>Returns the Hash of header metadata. If a <a
href="Document.html">Document</a> object is supplied, the metadatais
applied directly to the attributes of the <a
href="Document.html">Document</a>.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the <a href="Reader.html">Reader</a> holding the source lines of the
document</p>
</dd><dt>document
<dd>
<p>the <a href="Document.html">Document</a> we are building (default: nil)</p>
</dd></dl>

<h3 id="method-c-parse_header_metadata-label-Examples">Examples<span><a href="#method-c-parse_header_metadata-label-Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">parse_header_metadata</span>(<span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> [<span class="ruby-string">&quot;Author Name &lt;author@example.org&gt;\n&quot;</span>, <span class="ruby-string">&quot;v1.0, 2012-12-21: Coincide w/ end of world.\n&quot;</span>])
<span class="ruby-comment"># =&gt; {'author' =&gt; 'Author Name', 'firstname' =&gt; 'Author', 'lastname' =&gt; 'Name', 'email' =&gt; 'author@example.org',</span>
<span class="ruby-comment">#       'revnumber' =&gt; '1.0', 'revdate' =&gt; '2012-12-21', 'revremark' =&gt; 'Coincide w/ end of world.'}</span>
</pre>
          
          

          
          <div class="method-source-code" id="parse_header_metadata-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1606</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_header_metadata</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-comment"># NOTE this will discard away any comment lines, but not skip blank lines</span>
  <span class="ruby-identifier">process_attribute_entries</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

  <span class="ruby-identifier">metadata</span> = {}
  <span class="ruby-identifier">implicit_author</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">implicit_authors</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">next_line_empty?</span>
    <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_line</span>

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">author_metadata</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-comment"># apply header subs and assign to document</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">author_metadata</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">val</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">val</span> = <span class="ruby-identifier">val</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">apply_header_subs</span>(<span class="ruby-identifier">val</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">val</span>
          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">val</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">key</span>)
          <span class="ruby-identifier">val</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">implicit_author</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'author'</span>]
        <span class="ruby-identifier">implicit_authors</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'authors'</span>]
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">metadata</span> = <span class="ruby-identifier">author_metadata</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># NOTE this will discard any comment lines, but not skip blank lines</span>
    <span class="ruby-identifier">process_attribute_entries</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

    <span class="ruby-identifier">rev_metadata</span> = {}

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">next_line_empty?</span>
      <span class="ruby-identifier">rev_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_line</span> 
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">rev_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:revision_info</span>])
        <span class="ruby-identifier">rev_metadata</span>[<span class="ruby-string">'revdate'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">strip</span>
        <span class="ruby-identifier">rev_metadata</span>[<span class="ruby-string">'revnumber'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">rstrip</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">rev_metadata</span>[<span class="ruby-string">'revremark'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">rstrip</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># throw it back</span>
        <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">rev_line</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">rev_metadata</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-comment"># apply header subs and assign to document</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">rev_metadata</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">val</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">val</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">apply_header_subs</span>(<span class="ruby-identifier">val</span>)
          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">val</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">key</span>)
          <span class="ruby-identifier">val</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">metadata</span>.<span class="ruby-identifier">update</span> <span class="ruby-identifier">rev_metadata</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># NOTE this will discard any comment lines, but not skip blank lines</span>
    <span class="ruby-identifier">process_attribute_entries</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-comment"># process author attribute entries that override (or stand in for) the implicit author line</span>
    <span class="ruby-identifier">author_metadata</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'author'</span>) <span class="ruby-operator">&amp;&amp;</span>
        (<span class="ruby-identifier">author_line</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'author'</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">implicit_author</span>
      <span class="ruby-comment"># do not allow multiple, process as names only</span>
      <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">author_line</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'authors'</span>) <span class="ruby-operator">&amp;&amp;</span>
        (<span class="ruby-identifier">author_line</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'authors'</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">implicit_authors</span>
      <span class="ruby-comment"># allow multiple, process as names only</span>
      <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">author_line</span>, <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">authors</span> = []
      <span class="ruby-identifier">author_key</span> = <span class="ruby-node">&quot;author_#{authors.size + 1}&quot;</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-identifier">author_key</span>
        <span class="ruby-identifier">authors</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">author_key</span>]
        <span class="ruby-identifier">author_key</span> = <span class="ruby-node">&quot;author_#{authors.size + 1}&quot;</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">authors</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
        <span class="ruby-comment"># do not allow multiple, process as names only</span>
        <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">authors</span>.<span class="ruby-identifier">first</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">authors</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
        <span class="ruby-comment"># allow multiple, process as names only</span>
        <span class="ruby-identifier">author_metadata</span> = <span class="ruby-identifier">process_authors</span> <span class="ruby-identifier">authors</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">'; '</span>), <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">author_metadata</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">update</span> <span class="ruby-identifier">author_metadata</span>

      <span class="ruby-comment"># special case</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'email'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'email_1'</span>)
        <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'email'</span>] = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'email_1'</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">metadata</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_header_metadata-source -->
          
        </div>

        

        
      </div><!-- parse_header_metadata-method -->

    
      <div id="method-c-parse_manpage_header" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_manpage_header</span><span
            class="method-args">(reader, document)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parses the manpage header of the AsciiDoc source read from the <a
href="Reader.html">Reader</a></p>

<p>returns Nothing</p>
          
          

          
          <div class="method-source-code" id="parse_manpage_header-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 130</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_manpage_header</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">m</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'doctitle'</span>].<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:mantitle_manvolnum</span>]))
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'mantitle'</span>] = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">sub_attributes</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">rstrip</span>.<span class="ruby-identifier">downcase</span>)
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'manvolnum'</span>] = <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">strip</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: ERROR: #{reader.prev_line_info}: malformed manpage title&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, {})
    <span class="ruby-identifier">name_section</span> = <span class="ruby-identifier">initialize_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, {})
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">name_section</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">name_section_buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(<span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>).<span class="ruby-identifier">join</span>.<span class="ruby-identifier">tr_s</span>(<span class="ruby-string">&quot;\n &quot;</span>, <span class="ruby-string">' '</span>)
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">m</span> = <span class="ruby-identifier">name_section_buffer</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:manname_manpurpose</span>]))
        <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'manname'</span>] = <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>] 
        <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'manpurpose'</span>] = <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>] 
        <span class="ruby-comment"># TODO parse multiple man names</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">backend</span> <span class="ruby-operator">==</span> <span class="ruby-string">'manpage'</span>
          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'docname'</span>] = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'manname'</span>]
          <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'outfilesuffix'</span>] = <span class="ruby-node">&quot;.#{document.attributes['manvolnum']}&quot;</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: ERROR: #{reader.prev_line_info}: malformed name section body&quot;</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: ERROR: #{reader.prev_line_info}: name section title must be at level 1&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: ERROR: #{reader.prev_line_info}: name section expected&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_manpage_header-source -->
          
        </div>

        

        
      </div><!-- parse_manpage_header-method -->

    
      <div id="method-c-parse_style_attribute" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_style_attribute</span><span
            class="method-args">(attributes, reader = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse the first positional attribute and assign named attributes</p>

<p>Parse the first positional attribute to extract the style, role and
idparts, assign the values to their cooresponding attribute keys and
returnboth the original style attribute and the parsed value from the
firstpositional attribute.</p>
<dl class="rdoc-list note-list"><dt>attributes
<dd>
<p>The Hash of attributes to process and update</p>
</dd></dl>

<h3 id="method-c-parse_style_attribute-label-Examples">Examples<span><a href="#method-c-parse_style_attribute-label-Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">puts</span> <span class="ruby-identifier">attributes</span>
=<span class="ruby-operator">&gt;</span> {<span class="ruby-value">1</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-node">&quot;abstract#intro.lead%fragment&quot;</span>, <span class="ruby-string">&quot;style&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;preamble&quot;</span>}

<span class="ruby-identifier">parse_style_attribute</span>(<span class="ruby-identifier">attributes</span>)
=<span class="ruby-operator">&gt;</span> [<span class="ruby-string">&quot;abstract&quot;</span>, <span class="ruby-string">&quot;preamble&quot;</span>]

<span class="ruby-identifier">puts</span> <span class="ruby-identifier">attributes</span>
=<span class="ruby-operator">&gt;</span> {<span class="ruby-value">1</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-node">&quot;abstract#intro.lead&quot;</span>, <span class="ruby-string">&quot;style&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;abstract&quot;</span>, <span class="ruby-string">&quot;id&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;intro&quot;</span>,
      <span class="ruby-string">&quot;role&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;lead&quot;</span>, <span class="ruby-string">&quot;options&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;fragment&quot;</span>, <span class="ruby-string">&quot;option-fragment&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">''</span>}
</pre>

<p>Returns a two-element Array of the parsed style from thefirst positional
attribute and the original style that wasreplaced</p>
          
          

          
          <div class="method-source-code" id="parse_style_attribute-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2287</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_style_attribute</span>(<span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">reader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">original_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>]
  <span class="ruby-identifier">raw_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]
  <span class="ruby-comment"># NOTE the check for empty string is a hack to skip processing alt text on block macro</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">raw_style</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">raw_style</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">' '</span>)
    <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">raw_style</span>
    [<span class="ruby-identifier">raw_style</span>, <span class="ruby-identifier">original_style</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">type</span> = <span class="ruby-value">:style</span>
    <span class="ruby-identifier">collector</span> = []
    <span class="ruby-identifier">parsed</span> = {}
    <span class="ruby-comment"># QUESTION should this be a private method? (though, it's never called if shorthand isn't used)</span>
    <span class="ruby-identifier">save_current</span> = <span class="ruby-identifier">lambda</span> {
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">collector</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">type</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:style</span>
          <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: WARNING:#{reader.nil? ? nil : &quot; #{reader.prev_line_info}:&quot;} invalid empty #{type} detected in style attribute&quot;</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">case</span> <span class="ruby-identifier">type</span>
        <span class="ruby-keyword">when</span> <span class="ruby-value">:role</span>, <span class="ruby-value">:option</span>
          <span class="ruby-identifier">parsed</span>[<span class="ruby-identifier">type</span>] <span class="ruby-operator">||=</span> []
          <span class="ruby-identifier">parsed</span>[<span class="ruby-identifier">type</span>].<span class="ruby-identifier">push</span> <span class="ruby-identifier">collector</span>.<span class="ruby-identifier">join</span>
        <span class="ruby-keyword">when</span> <span class="ruby-value">:id</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">parsed</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-value">:id</span>
            <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: WARNING:#{reader.nil? ? nil : &quot; #{reader.prev_line_info}:&quot;} multiple ids detected in style attribute&quot;</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">parsed</span>[<span class="ruby-identifier">type</span>] = <span class="ruby-identifier">collector</span>.<span class="ruby-identifier">join</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">parsed</span>[<span class="ruby-identifier">type</span>] = <span class="ruby-identifier">collector</span>.<span class="ruby-identifier">join</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">collector</span> = []
      <span class="ruby-keyword">end</span>
    }

    <span class="ruby-identifier">raw_style</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">''</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">==</span> <span class="ruby-string">'.'</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">==</span> <span class="ruby-string">'#'</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">==</span> <span class="ruby-string">'%'</span>
        <span class="ruby-identifier">save_current</span>.<span class="ruby-identifier">call</span>
        <span class="ruby-keyword">case</span> <span class="ruby-identifier">c</span>
        <span class="ruby-keyword">when</span> <span class="ruby-string">'.'</span>
          <span class="ruby-identifier">type</span> = <span class="ruby-value">:role</span>
        <span class="ruby-keyword">when</span> <span class="ruby-string">'#'</span>
          <span class="ruby-identifier">type</span> = <span class="ruby-value">:id</span>
        <span class="ruby-keyword">when</span> <span class="ruby-string">'%'</span>
          <span class="ruby-identifier">type</span> = <span class="ruby-value">:option</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">collector</span>.<span class="ruby-identifier">push</span> <span class="ruby-identifier">c</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    
    <span class="ruby-comment"># small optimization if no shorthand is found</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:style</span>
      <span class="ruby-identifier">parsed_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">raw_style</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">save_current</span>.<span class="ruby-identifier">call</span>

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parsed</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-value">:style</span>
        <span class="ruby-identifier">parsed_style</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">parsed</span>[<span class="ruby-value">:style</span>]
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">parsed_style</span> = <span class="ruby-keyword">nil</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parsed</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-value">:id</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] = <span class="ruby-identifier">parsed</span>[<span class="ruby-value">:id</span>]
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parsed</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-value">:role</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'role'</span>] = <span class="ruby-identifier">parsed</span>[<span class="ruby-value">:role</span>] <span class="ruby-operator">*</span> <span class="ruby-string">' '</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parsed</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-value">:option</span>
        (<span class="ruby-identifier">options</span> = <span class="ruby-identifier">parsed</span>[<span class="ruby-value">:option</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">option</span><span class="ruby-operator">|</span>
          <span class="ruby-identifier">attributes</span>[<span class="ruby-node">&quot;#{option}-option&quot;</span>] = <span class="ruby-string">''</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'options'</span>] = <span class="ruby-identifier">options</span> <span class="ruby-operator">*</span> <span class="ruby-string">','</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    [<span class="ruby-identifier">parsed_style</span>, <span class="ruby-identifier">original_style</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_style_attribute-source -->
          
        </div>

        

        
      </div><!-- parse_style_attribute-method -->

    
      <div id="method-c-sanitize_attribute_name" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">sanitize_attribute_name</span><span
            class="method-args">(name)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Convert a string to a legal attribute name.</p>
<dl class="rdoc-list note-list"><dt>name
<dd>
<p>the String name of the attribute</p>
</dd></dl>

<p>Returns a String with the legal AsciiDoc attribute name.</p>

<h3 id="method-c-sanitize_attribute_name-label-Examples">Examples<span><a href="#method-c-sanitize_attribute_name-label-Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">sanitize_attribute_name</span>(<span class="ruby-string">'Foo Bar'</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-string">'foobar'</span>

<span class="ruby-identifier">sanitize_attribute_name</span>(<span class="ruby-string">'foo'</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-string">'foo'</span>

<span class="ruby-identifier">sanitize_attribute_name</span>(<span class="ruby-string">'Foo 3 #-Billy'</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-string">'foo3-billy'</span>
</pre>
          
          

          
          <div class="method-source-code" id="sanitize_attribute_name-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2463</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">sanitize_attribute_name</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-identifier">name</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:illegal_attr_name_chars</span>], <span class="ruby-string">''</span>).<span class="ruby-identifier">downcase</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- sanitize_attribute_name-source -->
          
        </div>

        

        
      </div><!-- sanitize_attribute_name-method -->

    
      <div id="method-c-store_attribute" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">store_attribute</span><span
            class="method-args">(name, value, doc = nil, attrs = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Store the attribute in the document and register attribute entry if
accessible</p>
<dl class="rdoc-list note-list"><dt>name
<dd>
<p>the String name of the attribute to store</p>
</dd><dt>value
<dd>
<p>the String value of the attribute to store</p>
</dd><dt>doc
<dd>
<p>the <a href="Document.html">Document</a> being parsed</p>
</dd><dt>attrs
<dd>
<p>the attributes for the current context</p>
</dd></dl>

<p>returns a 2-element array containing the attribute name and value</p>
          
          

          
          <div class="method-source-code" id="store_attribute-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1900</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">store_attribute</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">doc</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">attrs</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">'!'</span>)
    <span class="ruby-comment"># a nil value signals the attribute should be deleted (undefined)</span>
    <span class="ruby-identifier">value</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">chop</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'!'</span>)
    <span class="ruby-comment"># a nil value signals the attribute should be deleted (undefined)</span>
    <span class="ruby-identifier">value</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">name</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">name</span> = <span class="ruby-identifier">sanitize_attribute_name</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-identifier">accessible</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">accessible</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">delete_attribute</span>(<span class="ruby-identifier">name</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">set_attribute</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-operator">!</span><span class="ruby-identifier">accessible</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">attrs</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-constant">Document</span><span class="ruby-operator">::</span><span class="ruby-constant">AttributeEntry</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>).<span class="ruby-identifier">save_to</span>(<span class="ruby-identifier">attrs</span>)
  <span class="ruby-keyword">end</span>

  [<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- store_attribute-source -->
          
        </div>

        

        
      </div><!-- store_attribute-method -->

    
    </section><!-- public-class-method-details -->
  
  </section><!-- Public -->

  
  
  <section id="Internal" class="documentation-section">
    
    <div class="documentation-section-title">
      <h2 class="section-header">
        Internal
      </h2>
      <span class="section-click-top">
        <a href="#top">&uarr; top</a>
      </span>
    </div>
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-Internal-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-catalog_callouts" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">catalog_callouts</span><span
            class="method-args">(text, document)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Catalog any callouts found in the text, but dont process them</p>
<dl class="rdoc-list note-list"><dt>text
<dd>
<p>The String of text in which to look for callouts</p>
</dd><dt>document
<dd>
<p>The current document on which the callouts are stored</p>
</dd></dl>

<p>Returns nothing</p>
          
          

          
          <div class="method-source-code" id="catalog_callouts-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1025</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">catalog_callouts</span>(<span class="ruby-identifier">text</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">text</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:callout_quick_scan</span>]) {
    <span class="ruby-comment"># alias match for Ruby 1.8.7 compat</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">$~</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'\'</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">register</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>])
  }
<span class="ruby-keyword">end</span></pre>
          </div><!-- catalog_callouts-source -->
          
        </div>

        

        
      </div><!-- catalog_callouts-method -->

    
      <div id="method-c-catalog_inline_anchors" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">catalog_inline_anchors</span><span
            class="method-args">(text, document)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Catalog any inline anchors found in the text, but dont process them</p>
<dl class="rdoc-list note-list"><dt>text
<dd>
<p>The String text in which to look for inline anchors</p>
</dd><dt>document
<dd>
<p>The current document on which the references are stored</p>
</dd></dl>

<p>Returns nothing</p>
          
          

          
          <div class="method-source-code" id="catalog_inline_anchors-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1040</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">catalog_inline_anchors</span>(<span class="ruby-identifier">text</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">text</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor_macro</span>]) {
    <span class="ruby-comment"># alias match for Ruby 1.8.7 compat</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">$~</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'\'</span>
    <span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>)
    <span class="ruby-identifier">id</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dbl_quoted</span>], <span class="ruby-string">'\2'</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reftext</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">reftext</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:m_dbl_quoted</span>], <span class="ruby-string">'\2'</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span>])
  }
  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- catalog_inline_anchors-source -->
          
        </div>

        

        
      </div><!-- catalog_inline_anchors-method -->

    
      <div id="method-c-initialize_section" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">initialize_section</span><span
            class="method-args">(reader, parent, attributes = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Initialize a new <a href="Section.html">Section</a> object and assign any
attributes provided</p>

<p>The information for this section is retrieved by parsing the lines at
thecurrent position of the reader.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source reader</p>
</dd><dt>parent
<dd>
<p>the parent <a href="Section.html">Section</a> or <a
href="Document.html">Document</a> of this <a
href="Section.html">Section</a></p>
</dd><dt>attributes
<dd>
<p>a Hash of attributes to assign to this section (default: {})</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="initialize_section-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1383</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">initialize_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {})
  <span class="ruby-identifier">document</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>
  <span class="ruby-identifier">sect_id</span>, <span class="ruby-identifier">sect_title</span>, <span class="ruby-identifier">sect_level</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">section</span> = <span class="ruby-constant">Section</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">sect_level</span>, <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'numbered'</span>)
  <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">sect_id</span>
  <span class="ruby-identifier">section</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">sect_title</span>
  <span class="ruby-comment"># parse style, id and role from first positional attribute</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_style_attribute</span>(<span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">reader</span>)
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">special</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-comment"># HACK needs to be refactored so it's driven by config</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> <span class="ruby-operator">==</span> <span class="ruby-string">'abstract'</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'book'</span>
      <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> = <span class="ruby-string">&quot;sect1&quot;</span>
      <span class="ruby-identifier">section</span>.<span class="ruby-identifier">special</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-identifier">section</span>.<span class="ruby-identifier">level</span> = <span class="ruby-value">1</span>
    <span class="ruby-comment"># FIXME refactor to use assign_caption (also check requirements)</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> <span class="ruby-operator">==</span> <span class="ruby-string">'appendix'</span> <span class="ruby-operator">&amp;&amp;</span>
        <span class="ruby-operator">!</span><span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'caption'</span>) <span class="ruby-operator">&amp;&amp;</span>
        <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'caption'</span>)
      <span class="ruby-identifier">number</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">counter</span>(<span class="ruby-string">'appendix-number'</span>, <span class="ruby-string">'A'</span>)
      <span class="ruby-identifier">section</span>.<span class="ruby-identifier">caption</span> = <span class="ruby-node">&quot;#{document.attributes['appendix-caption']} #{number}: &quot;</span>
      <span class="ruby-constant">Document</span><span class="ruby-operator">::</span><span class="ruby-constant">AttributeEntry</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'appendix-number'</span>, <span class="ruby-identifier">number</span>).<span class="ruby-identifier">save_to</span>(<span class="ruby-identifier">attributes</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">sect_title</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-operator">==</span> <span class="ruby-string">'synopsis'</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'manpage'</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">special</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> = <span class="ruby-string">'synopsis'</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">sectname</span> = <span class="ruby-node">&quot;sect#{section.level}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">id</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>])
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">id</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># generate an id if one was not *embedded* in the heading line</span>
    <span class="ruby-comment"># or as an anchor above the section</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">generate_id</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">section</span>.<span class="ruby-identifier">title</span>])
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">section</span>.<span class="ruby-identifier">update_attributes</span>(<span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-identifier">section</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- initialize_section-source -->
          
        </div>

        

        
      </div><!-- initialize_section-method -->

    
      <div id="method-c-is_next_line_document_title-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_next_line_document_title?</span><span
            class="method-args">(reader, attributes)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Convenience API for checking if the next line on the <a
href="Reader.html">Reader</a> is the document title</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source <a href="Reader.html">Reader</a></p>
</dd><dt>attributes
<dd>
<p>a Hash of attributes collected above the current line</p>
</dd></dl>

<p>returns true if the <a href="Reader.html">Reader</a> is positioned at the
document title, false otherwise</p>
          
          

          
          <div class="method-source-code" id="is_next_line_document_title-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1463</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_next_line_document_title?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_next_line_document_title-3F-source -->
          
        </div>

        

        
      </div><!-- is_next_line_document_title-3F-method -->

    
      <div id="method-c-is_next_line_section-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_next_line_section?</span><span
            class="method-args">(reader, attributes)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Checks if the next line on the <a href="Reader.html">Reader</a> is a
section title</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source <a href="Reader.html">Reader</a></p>
</dd><dt>attributes
<dd>
<p>a Hash of attributes collected above the current line</p>
</dd></dl>

<p>returns the section level if the <a href="Reader.html">Reader</a> is
positioned at a section title,false otherwise</p>
          
          

          
          <div class="method-source-code" id="is_next_line_section-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1451</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">val</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]).<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> [<span class="ruby-string">'float'</span>, <span class="ruby-string">'discrete'</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">val</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
  <span class="ruby-constant">Compliance</span>.<span class="ruby-identifier">underline_style_section_titles</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">is_section_title?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_lines</span>(<span class="ruby-value">2</span>)) <span class="ruby-operator">:</span> <span class="ruby-identifier">is_section_title?</span>(<span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_next_line_section-3F-source -->
          
        </div>

        

        
      </div><!-- is_next_line_section-3F-method -->

    
      <div id="method-c-is_sibling_list_item-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_sibling_list_item?</span><span
            class="method-args">(line, list_type, sibling_trait)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Determine whether the this line is a sibling list itemaccording to the list
type and trait (marker) provided.</p>
<dl class="rdoc-list note-list"><dt>line
<dd>
<p>The String line to check</p>
</dd><dt>list_type
<dd>
<p>The context of the list (:olist, :ulist, :colist, :dlist)</p>
</dd><dt>sibling_trait
<dd>
<p>The String marker for the list or the Regexp to match a sibling</p>
</dd></dl>

<p>Returns a Boolean indicating whether this line is a sibling list item
giventhe criteria provided</p>
          
          

          
          <div class="method-source-code" id="is_sibling_list_item-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2025</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sibling_trait</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Regexp</span>)
    <span class="ruby-identifier">matcher</span> = <span class="ruby-identifier">sibling_trait</span>
    <span class="ruby-identifier">expected_marker</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">matcher</span> = <span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">list_type</span>]
    <span class="ruby-identifier">expected_marker</span> = <span class="ruby-identifier">sibling_trait</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">matcher</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">expected_marker</span>
      <span class="ruby-identifier">expected_marker</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>])
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_sibling_list_item-3F-source -->
          
        </div>

        

        
      </div><!-- is_sibling_list_item-3F-method -->

    
      <div id="method-c-next_labeled_list" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_labeled_list</span><span
            class="method-args">(reader, match, parent)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse and construct a labeled (e.g., definition) list <a
href="Block.html">Block</a> from the current position of the <a
href="Reader.html">Reader</a></p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the labeled
list</p>
</dd><dt>match
<dd>
<p>The Regexp match for the head of the list</p>
</dd><dt>parent
<dd>
<p>The parent <a href="Block.html">Block</a> to which this labeled list
belongs</p>
</dd></dl>

<p>Returns the <a href="Block.html">Block</a> encapsulating the parsed labeled
list</p>
          
          

          
          <div class="method-source-code" id="next_labeled_list-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1062</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_labeled_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">parent</span>)
  <span class="ruby-identifier">list_block</span> = <span class="ruby-constant">List</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:dlist</span>)
  <span class="ruby-identifier">previous_pair</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-comment"># allows us to capture until we find a labeled item</span>
  <span class="ruby-comment"># that uses the same delimiter (::, :::, :::: or ;;)</span>
  <span class="ruby-identifier">sibling_pattern</span> = <span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dlist_siblings</span>][<span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]]

  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">term</span>, <span class="ruby-identifier">item</span> = <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">sibling_pattern</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">previous_pair</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">previous_pair</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">previous_pair</span>.<span class="ruby-identifier">pop</span>
      <span class="ruby-identifier">previous_pair</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">term</span>
      <span class="ruby-identifier">previous_pair</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">item</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># FIXME this misses the automatic parent assignment</span>
      <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">items</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">previous_pair</span> = [[<span class="ruby-identifier">term</span>], <span class="ruby-identifier">item</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">sibling_pattern</span>)

  <span class="ruby-identifier">list_block</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_labeled_list-source -->
          
        </div>

        

        
      </div><!-- next_labeled_list-method -->

    
      <div id="method-c-next_list_item" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_list_item</span><span
            class="method-args">(reader, list_block, match, sibling_trait = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse and construct the next <a href="ListItem.html">ListItem</a> for the
current bulleted(unordered or ordered) list <a href="Block.html">Block</a>,
callout lists included, or the nextterm <a
href="ListItem.html">ListItem</a> and definition <a
href="ListItem.html">ListItem</a> pair for the labeled list <a
href="Block.html">Block</a>.</p>

<p>First collect and process all the lines that constitute the next listitem
for the parent list (according to its type). Next, parse those linesinto
blocks and associate them with the <a href="ListItem.html">ListItem</a> (in
the case of alabeled list, the definition <a
href="ListItem.html">ListItem</a>). Finally, fold the first blockinto the
items text attribute according to rules described in <a
href="ListItem.html">ListItem</a>.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the next list
item</p>
</dd><dt>list_block
<dd>
<p>The parent list <a href="Block.html">Block</a> of this <a
href="ListItem.html">ListItem</a>. Also provides access to the list type.</p>
</dd><dt>match
<dd>
<p>The match Array which contains the marker and text (first-line) of the <a
href="ListItem.html">ListItem</a></p>
</dd><dt>sibling_trait
<dd>
<p>The list marker or the Regexp to match a sibling item</p>
</dd></dl>

<p>Returns the next <a href="ListItem.html">ListItem</a> or <a
href="ListItem.html">ListItem</a> pair (depending on the list type)for the
parent list <a href="Block.html">Block</a>.</p>
          
          

          
          <div class="method-source-code" id="next_list_item-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1101</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">list_type</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">context</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span>
    <span class="ruby-identifier">list_term</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>])
    <span class="ruby-identifier">list_item</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>])
    <span class="ruby-identifier">has_text</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Create list item using first line as the text of the list item</span>
    <span class="ruby-identifier">text</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]
    <span class="ruby-identifier">checkbox</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:ulist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">text</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'['</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">text</span>.<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'[ ] '</span>
        <span class="ruby-identifier">checkbox</span> = <span class="ruby-keyword">true</span>
        <span class="ruby-identifier">checked</span> = <span class="ruby-keyword">false</span>
        <span class="ruby-identifier">text</span> = <span class="ruby-identifier">text</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">lstrip</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">text</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'[*] '</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">text</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'[x] '</span>)
        <span class="ruby-identifier">checkbox</span> = <span class="ruby-keyword">true</span>
        <span class="ruby-identifier">checked</span> = <span class="ruby-keyword">true</span>
        <span class="ruby-identifier">text</span> = <span class="ruby-identifier">text</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">lstrip</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">list_item</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">text</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">checkbox</span>
      <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'checklist-option'</span>] = <span class="ruby-string">''</span>
      <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'checkbox'</span>] = <span class="ruby-string">''</span>
      <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'checked'</span>] = <span class="ruby-string">''</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">checked</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">sibling_trait</span>
      <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span>, <span class="ruby-keyword">true</span>, <span class="ruby-identifier">reader</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">marker</span> = <span class="ruby-identifier">sibling_trait</span>
    <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># first skip the line with the marker / term</span>
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
  <span class="ruby-identifier">cursor</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">cursor</span>
  <span class="ruby-identifier">list_item_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">read_lines_for_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>, <span class="ruby-identifier">has_text</span>), <span class="ruby-identifier">cursor</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">comment_lines</span> = <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">skip_line_comments</span>
    <span class="ruby-identifier">subsequent_line</span> = <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">peek_line</span>
    <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">unshift_lines</span> <span class="ruby-identifier">comment_lines</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">comment_lines</span>.<span class="ruby-identifier">empty?</span> 

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">subsequent_line</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">continuation_connects_first_block</span> = (<span class="ruby-identifier">subsequent_line</span> <span class="ruby-operator">==</span> <span class="ruby-operator">::</span><span class="ruby-constant">Asciidoctor</span><span class="ruby-operator">::</span><span class="ruby-constant">EOL</span>)
      <span class="ruby-comment"># if there's no continuation connecting the first block, then</span>
      <span class="ruby-comment"># treat the lines as paragraph text (activated when has_text = false)</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">continuation_connects_first_block</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:dlist</span>
        <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">content_adjacent</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">subsequent_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">continuation_connects_first_block</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-identifier">content_adjacent</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># only relevant for :dlist</span>
    <span class="ruby-identifier">options</span> = {<span class="ruby-value">:text</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">has_text</span>}

    <span class="ruby-comment"># we can look for blocks until there are no more lines (and not worry</span>
    <span class="ruby-comment"># about sections) since the reader is confined within the boundaries of a</span>
    <span class="ruby-comment"># list</span>
    <span class="ruby-keyword">while</span> <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
      <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">list_item_reader</span>, <span class="ruby-identifier">list_block</span>, {}, <span class="ruby-identifier">options</span>)
      <span class="ruby-identifier">list_item</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">fold_first</span>(<span class="ruby-identifier">continuation_connects_first_block</span>, <span class="ruby-identifier">content_adjacent</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">text?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">blocks?</span>
      <span class="ruby-identifier">list_item</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
    [<span class="ruby-identifier">list_term</span>, <span class="ruby-identifier">list_item</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">list_item</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_list_item-source -->
          
        </div>

        

        
      </div><!-- next_list_item-method -->

    
      <div id="method-c-next_outline_list" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_outline_list</span><span
            class="method-args">(reader, list_type, parent)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse and construct an outline list <a href="Block.html">Block</a> from the
current position of the <a href="Reader.html">Reader</a></p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the outline
list</p>
</dd><dt>list_type
<dd>
<p>A Symbol representing the list type (:olist for ordered, :ulist for
unordered)</p>
</dd><dt>parent
<dd>
<p>The parent <a href="Block.html">Block</a> to which this outline list
belongs</p>
</dd></dl>

<p>Returns the <a href="Block.html">Block</a> encapsulating the parsed outline
(unordered or ordered) list</p>
          
          

          
          <div class="method-source-code" id="next_outline_list-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 969</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">parent</span>)
  <span class="ruby-identifier">list_block</span> = <span class="ruby-constant">List</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">list_type</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_type</span>
    <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment">#Debug.debug { &quot;Created #{list_type} block: #{list_block}&quot; }</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">list_type</span>]))
    <span class="ruby-identifier">marker</span> = <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>])

    <span class="ruby-comment"># if we are moving to the next item, and the marker is different</span>
    <span class="ruby-comment"># determine if we are moving up or down in nesting</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">items?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">marker</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">items</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
      <span class="ruby-comment"># assume list is nested by default, but then check to see if we are</span>
      <span class="ruby-comment"># popping out of a nested list by matching an ancestor's list marker</span>
      <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">ancestor</span> = <span class="ruby-identifier">parent</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">ancestor</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_type</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">marker</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">ancestor</span>.<span class="ruby-identifier">items</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
          <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">ancestor</span>.<span class="ruby-identifier">level</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">ancestor</span> = <span class="ruby-identifier">ancestor</span>.<span class="ruby-identifier">parent</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">items?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-identifier">list_item</span> = <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>)
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-comment"># leave this block</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-comment"># If this next list level is down one from the</span>
      <span class="ruby-comment"># current Block's, append it to content of the current list item</span>
      <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">items</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">list_block</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">list_item</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">list_item</span> = <span class="ruby-keyword">nil</span>

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">list_block</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_outline_list-source -->
          
        </div>

        

        
      </div><!-- next_outline_list-method -->

    
      <div id="method-c-next_table" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_table</span><span
            class="method-args">(table_reader, parent, attributes)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse the table contained in the provided <a href="Reader.html">Reader</a></p>
<dl class="rdoc-list note-list"><dt>table_reader
<dd>
<p>a <a href="Reader.html">Reader</a> containing the source lines of an
AsciiDoc table</p>
</dd><dt>parent
<dd>
<p>the parent <a href="Block.html">Block</a> of this <a
href="Table.html">Asciidoctor::Table</a></p>
</dd><dt>attributes
<dd>
<p>attributes captured from above this <a href="Block.html">Block</a></p>
</dd></dl>

<p>returns an instance of <a href="Table.html">Asciidoctor::Table</a> parsed
from the provided reader</p>
          
          

          
          <div class="method-source-code" id="next_table-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2052</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_table</span>(<span class="ruby-identifier">table_reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">table</span> = <span class="ruby-constant">Table</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'title'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'title'</span>)
  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">assign_caption</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">'caption'</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'cols'</span>
    <span class="ruby-identifier">table</span>.<span class="ruby-identifier">create_columns</span>(<span class="ruby-identifier">parse_col_specs</span>(<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'cols'</span>]))
    <span class="ruby-identifier">explicit_col_specs</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">explicit_col_specs</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">skipped</span> = <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-identifier">parser_ctx</span> = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ParserContext</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">table_reader</span>, <span class="ruby-identifier">table</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">loop_idx</span> = <span class="ruby-value">-1</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">loop_idx</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">line</span> = <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">read_line</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">skipped</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">loop_idx</span>.<span class="ruby-identifier">zero?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'options'</span>) <span class="ruby-operator">&amp;&amp;</span>
        <span class="ruby-operator">!</span>(<span class="ruby-identifier">next_line</span> = <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">peek_line</span>).<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">next_line</span> <span class="ruby-operator">==</span> <span class="ruby-operator">::</span><span class="ruby-constant">Asciidoctor</span><span class="ruby-operator">::</span><span class="ruby-constant">EOL</span>
      <span class="ruby-identifier">table</span>.<span class="ruby-identifier">has_header_option</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'options'</span>] = <span class="ruby-string">'header'</span>
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'header-option'</span>] = <span class="ruby-string">''</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">starts_with_delimiter?</span> <span class="ruby-identifier">line</span>
        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">line</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
        <span class="ruby-comment"># push an empty cell spec if boundary at start of line</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_open_cell</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">next_cell_spec</span>, <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">line</span>, <span class="ruby-value">:start</span>)
        <span class="ruby-comment"># if the cell spec is not null, then we're at a cell boundary</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">next_cell_spec</span>.<span class="ruby-identifier">nil?</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_open_cell</span> <span class="ruby-identifier">next_cell_spec</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-comment"># QUESTION do we not advance to next line? if so, when will we if we came into this block?</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">while</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">match_delimiter</span>(<span class="ruby-identifier">line</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer_has_unclosed_quotes?</span>(<span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>)
            <span class="ruby-comment"># throw it back, it's too small</span>
            <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">skip_matched_delimiter</span>(<span class="ruby-identifier">m</span>)
            <span class="ruby-keyword">next</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>.<span class="ruby-identifier">end_with?</span> <span class="ruby-string">'\'</span>
            <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">skip_matched_delimiter</span>(<span class="ruby-identifier">m</span>, <span class="ruby-keyword">true</span>)
            <span class="ruby-keyword">next</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span>
          <span class="ruby-identifier">next_cell_spec</span>, <span class="ruby-identifier">cell_text</span> = <span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>, <span class="ruby-value">:end</span>)
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">push_cell_spec</span> <span class="ruby-identifier">next_cell_spec</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-node">%Q(#{parser_ctx.buffer}#{cell_text})</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-node">%Q(#{parser_ctx.buffer}#{m.pre_match})</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">m</span>.<span class="ruby-identifier">post_match</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># no other delimiters to see here</span>
        <span class="ruby-comment"># suck up this line into the buffer and move on</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-node">%Q(#{parser_ctx.buffer}#{line})</span>
        <span class="ruby-comment"># QUESTION make stripping endlines in csv data an option? (unwrap-option?)</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-node">%Q(#{parser_ctx.buffer.rstrip} )</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">line</span> = <span class="ruby-string">''</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span> <span class="ruby-operator">&amp;&amp;</span>
            <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer_has_unclosed_quotes?</span>)
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">keep_cell_open</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span> <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">skipped</span> = <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">skip_blank_lines</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">cell_open?</span>

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">has_more_lines?</span>
      <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'colcount'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">col_count</span>

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">explicit_col_specs</span>
    <span class="ruby-comment"># TODO further encapsulate this logic (into table perhaps?)</span>
    <span class="ruby-identifier">even_width</span> = (<span class="ruby-value">100.0</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">col_count</span>).<span class="ruby-identifier">floor</span>
    <span class="ruby-identifier">table</span>.<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">assign_width</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">even_width</span>) }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">partition_header_footer</span> <span class="ruby-identifier">attributes</span>

  <span class="ruby-identifier">table</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_table-source -->
          
        </div>

        

        
      </div><!-- next_table-method -->

    
      <div id="method-c-parse_block_metadata_line" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_block_metadata_line</span><span
            class="method-args">(reader, parent, attributes, options = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse the next line if it contains metadata for the following block</p>

<p>This method handles lines with the following content:</p>

<p>* line or block comment* anchor* attribute list* block title</p>

<p>Any attributes found will be inserted into the attributes argument.If the
line contains block metadata, the method returns true, otherwise false.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source reader</p>
</dd><dt>parent
<dd>
<p>the parent of the current line</p>
</dd><dt>attributes
<dd>
<p>a Hash of attributes in which any metadata found will be stored</p>
</dd><dt>options
<dd>
<p>a Hash of options to control processing: (default: {})*  :text indicates
that lexer is only looking for text contentand thus the block title should
not be captured</p>
</dd></dl>

<p>returns true if the line contains metadata, otherwise false</p>
          
          

          
          <div class="method-source-code" id="parse_block_metadata_line-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1824</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
  <span class="ruby-identifier">next_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">commentish</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'//'</span>)) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:comment_blk</span>]))
    <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(<span class="ruby-value">:skip_first_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:skip_processing</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">commentish</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:comment</span>])
    <span class="ruby-comment"># do nothing, we'll skip it</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_entry</span>]))
    <span class="ruby-identifier">process_attribute_entry</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">match</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor</span>])
    <span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>)
    <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] = <span class="ruby-identifier">id</span>
    <span class="ruby-comment"># AsciiDoc always uses [id] as the reftext in HTML output,</span>
    <span class="ruby-comment"># but I'd like to do better in Asciidoctor</span>
    <span class="ruby-comment">#parent.document.register(:ids, id)</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">reftext</span>
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'reftext'</span>] = <span class="ruby-identifier">reftext</span>
      <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:blk_attr_list</span>])
    <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">parse_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>], [], <span class="ruby-value">:sub_input</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:into</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">attributes</span>)
  <span class="ruby-comment"># NOTE title doesn't apply to section, but we need to stash it for the first block</span>
  <span class="ruby-comment"># TODO should issue an error if this is found above the document title</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:blk_title</span>]))
    <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_block_metadata_line-source -->
          
        </div>

        

        
      </div><!-- parse_block_metadata_line-method -->

    
      <div id="method-c-parse_block_metadata_lines" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_block_metadata_lines</span><span
            class="method-args">(reader, parent, attributes = {}, options = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse lines of metadata until a line of metadata is not found.</p>

<p>This method processes sequential lines containing block metadata,
ignoringblank lines and comments.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source reader</p>
</dd><dt>parent
<dd>
<p>the parent to which the lines belong</p>
</dd><dt>attributes
<dd>
<p>a Hash of attributes in which any metadata found will be stored (default:
{})</p>
</dd><dt>options
<dd>
<p>a Hash of options to control processing: (default: {})*  :text indicates
that lexer is only looking for text contentand thus the block title should
not be captured</p>
</dd></dl>

<p>returns the Hash of attributes including any metadata found</p>
          
          

          
          <div class="method-source-code" id="parse_block_metadata_lines-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1795</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {}, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span>)
    <span class="ruby-comment"># discard the line just processed</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">attributes</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_block_metadata_lines-source -->
          
        </div>

        

        
      </div><!-- parse_block_metadata_lines-method -->

    
      <div id="method-c-parse_cell_spec" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_cell_spec</span><span
            class="method-args">(line, pos = :start)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse the cell specs for the current cell.</p>

<p>The cell specs dictate the cells alignments, styles or filters,colspan,
rowspan and/or repeating content.</p>

<p>returns the Hash of attributes that indicate how to layoutand style this
cell in the table.</p>
          
          

          
          <div class="method-source-code" id="parse_cell_spec-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2221</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">pos</span> = <span class="ruby-value">:start</span>)
  <span class="ruby-comment"># the default for the end pos it {} since we</span>
  <span class="ruby-comment"># know we're at a delimiter; when the pos</span>
  <span class="ruby-comment"># is start, we *may* be at a delimiter and</span>
  <span class="ruby-comment"># nil indicates we're not</span>
  <span class="ruby-identifier">spec</span> = (<span class="ruby-identifier">pos</span> <span class="ruby-operator">==</span> <span class="ruby-value">:end</span> <span class="ruby-operator">?</span> {} <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">line</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:table_cellspec</span>][<span class="ruby-identifier">pos</span>]) 
    <span class="ruby-identifier">spec</span> = {}
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">line</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">rest</span> = (<span class="ruby-identifier">pos</span> <span class="ruby-operator">==</span> <span class="ruby-value">:start</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">post_match</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>]
      <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
      <span class="ruby-identifier">colspec</span> = <span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'+'</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'colspan'</span>] = <span class="ruby-identifier">colspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">colspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'rowspan'</span>] = <span class="ruby-identifier">rowspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">rowspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'*'</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'repeatcol'</span>] = <span class="ruby-identifier">colspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">colspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>]
      <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">colspec</span>)
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'halign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>][<span class="ruby-identifier">colspec</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">rowspec</span>)
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'valign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>][<span class="ruby-identifier">rowspec</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>])
      <span class="ruby-identifier">spec</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>[<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>]]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span> 

  [<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">rest</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_cell_spec-source -->
          
        </div>

        

        
      </div><!-- parse_cell_spec-method -->

    
      <div id="method-c-parse_col_specs" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_col_specs</span><span
            class="method-args">(records)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse the column specs for this table.</p>

<p>The column specs dictate the number of columns, relativewidth of columns,
default alignments for cells in eachcolumn, and/or default styles or
filters applied to the cells in the column.</p>

<p>Every column spec is guaranteed to have a width</p>

<p>returns a Hash of attributes that specify how to formatand layout the cells
in the table.</p>
          
          

          
          <div class="method-source-code" id="parse_col_specs-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2169</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_col_specs</span>(<span class="ruby-identifier">records</span>)
  <span class="ruby-identifier">specs</span> = []

  <span class="ruby-comment"># check for deprecated syntax</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">records</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:digits</span>])
    <span class="ruby-value">1</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">to_i</span>) {
      <span class="ruby-identifier">specs</span> <span class="ruby-operator">&lt;&lt;</span> {<span class="ruby-string">'width'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">specs</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">records</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">record</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># TODO might want to use scan rather than this mega-regexp</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">record</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:table_colspec</span>])
      <span class="ruby-identifier">spec</span> = {}
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>]
        <span class="ruby-comment"># make this an operation</span>
        <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">colspec</span>)
          <span class="ruby-identifier">spec</span>[<span class="ruby-string">'halign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>][<span class="ruby-identifier">colspec</span>]
        <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">rowspec</span>)
          <span class="ruby-identifier">spec</span>[<span class="ruby-string">'valign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>][<span class="ruby-identifier">rowspec</span>]
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># to_i permits us to support percentage width by stripping the %</span>
      <span class="ruby-comment"># NOTE this is slightly out of compliance w/ AsciiDoc, but makes way more sense</span>
      <span class="ruby-identifier">spec</span>[<span class="ruby-string">'width'</span>] = <span class="ruby-operator">!</span><span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span>

      <span class="ruby-comment"># make this an operation</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>])
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>[<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>]]
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">repeat</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span>

      <span class="ruby-value">1</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">repeat</span>) {
        <span class="ruby-identifier">specs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">spec</span>.<span class="ruby-identifier">dup</span>
      }
    <span class="ruby-keyword">end</span>
  }
  <span class="ruby-identifier">specs</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_col_specs-source -->
          
        </div>

        

        
      </div><!-- parse_col_specs-method -->

    
      <div id="method-c-parse_section_title" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_section_title</span><span
            class="method-args">(reader, document)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse the section title from the current position of the reader</p>

<p>Parse a single or double-line section title. After this method is
called,the <a href="Reader.html">Reader</a> will be positioned at the line
after the section title.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source reader, positioned at a section titledocument- the current
document</p>
</dd></dl>

<h3 id="method-c-parse_section_title-label-Examples">Examples<span><a href="#method-c-parse_section_title-label-Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">lines</span>
<span class="ruby-comment"># =&gt; [&quot;Foo\n&quot;, &quot;~~~\n&quot;]</span>

<span class="ruby-identifier">title</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">id</span>, <span class="ruby-identifier">single</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

<span class="ruby-identifier">title</span>
<span class="ruby-comment"># =&gt; &quot;Foo&quot;</span>
<span class="ruby-identifier">level</span>
<span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">id</span>
<span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">single</span>
<span class="ruby-comment"># =&gt; false</span>

<span class="ruby-identifier">line1</span>
<span class="ruby-comment"># =&gt; &quot;==== Foo\n&quot;</span>

<span class="ruby-identifier">title</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">id</span>, <span class="ruby-identifier">single</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

<span class="ruby-identifier">title</span>
<span class="ruby-comment"># =&gt; &quot;Foo&quot;</span>
<span class="ruby-identifier">level</span>
<span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">id</span>
<span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">single</span>
<span class="ruby-comment"># =&gt; true</span>
</pre>

<p>returns an Array of [String, Integer, String, Boolean], representing theid,
title, level and line count of the <a href="Section.html">Section</a>, or
nil.</p>
          
          

          
          <div class="method-source-code" id="parse_section_title-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1548</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">line1</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_line</span>
  <span class="ruby-identifier">sect_id</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">sect_title</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">sect_level</span> = <span class="ruby-value">-1</span>
  <span class="ruby-identifier">single_line</span> = <span class="ruby-keyword">true</span>

  <span class="ruby-identifier">first_char</span> = <span class="ruby-identifier">line1</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">first_char</span> <span class="ruby-operator">==</span> <span class="ruby-string">'='</span> <span class="ruby-operator">||</span> (<span class="ruby-constant">Compliance</span>.<span class="ruby-identifier">markdown_syntax</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">first_char</span> <span class="ruby-operator">==</span> <span class="ruby-string">'#'</span>)) <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_title</span>]))
    <span class="ruby-identifier">sect_id</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>]
    <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]
    <span class="ruby-identifier">sect_level</span> = <span class="ruby-identifier">single_line_section_level</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">elsif</span> <span class="ruby-constant">Compliance</span>.<span class="ruby-identifier">underline_style_section_titles</span>
    <span class="ruby-identifier">line2</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line2</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">SECTION_LEVELS</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">line2</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_underline</span>]) <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">name_match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_name</span>])) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-comment"># chomp so that a (non-visible) endline does not impact calculation</span>
      (<span class="ruby-identifier">line_length</span>(<span class="ruby-identifier">line1</span>) <span class="ruby-operator">-</span> <span class="ruby-identifier">line_length</span>(<span class="ruby-identifier">line2</span>)).<span class="ruby-identifier">abs</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">anchor_match</span> = <span class="ruby-identifier">name_match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor_embedded</span>]) 
        <span class="ruby-identifier">sect_id</span> = <span class="ruby-identifier">anchor_match</span>[<span class="ruby-value">2</span>]
        <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">anchor_match</span>[<span class="ruby-value">1</span>]
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">name_match</span>[<span class="ruby-value">1</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">sect_level</span> = <span class="ruby-identifier">section_level</span> <span class="ruby-identifier">line2</span>
      <span class="ruby-identifier">single_line</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">advance</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sect_level</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">sect_level</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attr</span>(<span class="ruby-string">'leveloffset'</span>, <span class="ruby-value">0</span>).<span class="ruby-identifier">to_i</span>
  <span class="ruby-keyword">end</span>
  [<span class="ruby-identifier">sect_id</span>, <span class="ruby-identifier">sect_title</span>, <span class="ruby-identifier">sect_level</span>, <span class="ruby-identifier">single_line</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_section_title-source -->
          
        </div>

        

        
      </div><!-- parse_section_title-method -->

    
      <div id="method-c-process_authors" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process_authors</span><span
            class="method-args">(author_line, names_only = false, multiple = true)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse the author line into a Hash of author metadata</p>
<dl class="rdoc-list note-list"><dt>author_line
<dd>
<p>the String author line</p>
</dd><dt>names_only
<dd>
<p>a Boolean flag that indicates whether to process line asnames only or names
with emails (default: false)</p>
</dd><dt>multiple
<dd>
<p>a Boolean flag that indicates whether to process
multiplesemicolon-separated entries in the author line (default: true)</p>
</dd></dl>

<p>returns a Hash of author metadata</p>
          
          

          
          <div class="method-source-code" id="process_authors-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1718</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">process_authors</span>(<span class="ruby-identifier">author_line</span>, <span class="ruby-identifier">names_only</span> = <span class="ruby-keyword">false</span>, <span class="ruby-identifier">multiple</span> = <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">author_metadata</span> = {}
  <span class="ruby-identifier">keys</span> = [<span class="ruby-string">'author'</span>, <span class="ruby-string">'authorinitials'</span>, <span class="ruby-string">'firstname'</span>, <span class="ruby-string">'middlename'</span>, <span class="ruby-string">'lastname'</span>, <span class="ruby-string">'email'</span>]
  <span class="ruby-identifier">author_entries</span> = <span class="ruby-identifier">multiple</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">author_line</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">';'</span>).<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:strip</span>) <span class="ruby-operator">:</span> [<span class="ruby-identifier">author_line</span>]
  <span class="ruby-identifier">author_entries</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">author_entry</span>, <span class="ruby-identifier">idx</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">strip!</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">key_map</span> = {}
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">idx</span>.<span class="ruby-identifier">zero?</span>
      <span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">key_map</span>[<span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_sym</span>] = <span class="ruby-identifier">key</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">key_map</span>[<span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_sym</span>] = <span class="ruby-node">&quot;#{key}_#{idx + 1}&quot;</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">segments</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">names_only</span>
      <span class="ruby-comment"># splitting on ' ' will collapse repeating spaces</span>
      <span class="ruby-identifier">segments</span> = <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">' '</span>, <span class="ruby-value">3</span>)
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:author_info</span>]))
      <span class="ruby-identifier">segments</span> = <span class="ruby-identifier">match</span>.<span class="ruby-identifier">to_a</span>
      <span class="ruby-identifier">segments</span>.<span class="ruby-identifier">shift</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">segments</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:firstname</span>]] = <span class="ruby-identifier">fname</span> = <span class="ruby-identifier">segments</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]] = <span class="ruby-identifier">fname</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:authorinitials</span>]] = <span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">segments</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">segments</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:middlename</span>]] = <span class="ruby-identifier">mname</span> = <span class="ruby-identifier">segments</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:lastname</span>]] = <span class="ruby-identifier">lname</span> = <span class="ruby-identifier">segments</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]] = [<span class="ruby-identifier">fname</span>, <span class="ruby-identifier">mname</span>, <span class="ruby-identifier">lname</span>].<span class="ruby-identifier">join</span> <span class="ruby-string">' '</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:authorinitials</span>]] = [<span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">mname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">lname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]].<span class="ruby-identifier">join</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">segments</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:lastname</span>]] = <span class="ruby-identifier">lname</span> = <span class="ruby-identifier">segments</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]] = [<span class="ruby-identifier">fname</span>, <span class="ruby-identifier">lname</span>].<span class="ruby-identifier">join</span> <span class="ruby-string">' '</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:authorinitials</span>]] = [<span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">lname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]].<span class="ruby-identifier">join</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:email</span>]] = <span class="ruby-identifier">segments</span>[<span class="ruby-value">3</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">names_only</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">segments</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]] = <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:firstname</span>]] = <span class="ruby-identifier">fname</span> = <span class="ruby-identifier">author_entry</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-string">' '</span>)
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:authorinitials</span>]] = <span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">author_metadata</span>[<span class="ruby-string">'authorcount'</span>] = <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
    <span class="ruby-comment"># only assign the _1 attributes if there are multiple authors</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">author_metadata</span>[<span class="ruby-node">&quot;#{key}_1&quot;</span>] = <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">author_metadata</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-identifier">key</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">idx</span>.<span class="ruby-identifier">zero?</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-string">'authors'</span>] = <span class="ruby-identifier">author_metadata</span>[<span class="ruby-identifier">key_map</span>[<span class="ruby-value">:author</span>]]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">author_metadata</span>[<span class="ruby-string">'authors'</span>] = <span class="ruby-node">&quot;#{author_metadata['authors']}, #{author_metadata[key_map[:author]]}&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">author_metadata</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- process_authors-source -->
          
        </div>

        

        
      </div><!-- process_authors-method -->

    
      <div id="method-c-read_lines_for_list_item" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">read_lines_for_list_item</span><span
            class="method-args">(reader, list_type, sibling_trait = nil, has_text = true)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Collect the lines belonging to the current list item, navigatingthrough all
the rules that determine what comprises a list item.</p>

<p>Grab lines until a sibling list item is found, or the block is broken by
aterminator (such as a line comment). Definition lists are more greedy
ifthey dont have optional inline item textthey want that text</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the lines.</p>
</dd><dt>list_type
<dd>
<p>The Symbol context of the list (:ulist, :olist, :colist or :dlist)</p>
</dd><dt>sibling_trait
<dd>
<p>A Regexp that matches a sibling of this list item or String list marker of
the items in this list (default: nil)</p>
</dd><dt>has_text
<dd>
<p>Whether the list item has text defined inline (always true except for
labeled lists)</p>
</dd></dl>

<p>Returns an Array of lines belonging to the current list item.</p>
          
          

          
          <div class="method-source-code" id="read_lines_for_list_item-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1198</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">read_lines_for_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">buffer</span> = []

  <span class="ruby-comment"># three states for continuation: :inactive, :active &amp; :frozen</span>
  <span class="ruby-comment"># :frozen signifies we've detected sequential continuation lines &amp;</span>
  <span class="ruby-comment"># continuation is not permitted until reset </span>
  <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>

  <span class="ruby-comment"># if we are within a nested list, we don't throw away the list</span>
  <span class="ruby-comment"># continuation marks because they will be processed when grabbing</span>
  <span class="ruby-comment"># the lines for those nested lists</span>
  <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-comment"># a detached continuation is a list continuation that follows a blank line</span>
  <span class="ruby-comment"># it gets associated with the outermost block</span>
  <span class="ruby-identifier">detached_continuation</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_more_lines?</span>
    <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_line</span>

    <span class="ruby-comment"># if we've arrived at a sibling item in this list, we've captured</span>
    <span class="ruby-comment"># the complete list item and can begin processing it</span>
    <span class="ruby-comment"># the remainder of the method determines whether we've reached</span>
    <span class="ruby-comment"># the termination of the list</span>
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)

    <span class="ruby-identifier">prev_line</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">prev_line</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:inactive</span>
        <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:active</span>
        <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
        <span class="ruby-identifier">buffer</span>[<span class="ruby-value">-1</span>] = <span class="ruby-operator">::</span><span class="ruby-constant">Asciidoctor</span><span class="ruby-operator">::</span><span class="ruby-constant">EOL</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">within_nested_list</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># dealing with adjacent list continuations (which is really a syntax error)</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:frozen</span>
          <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:frozen</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">this_line</span> = <span class="ruby-keyword">nil</span>
        <span class="ruby-keyword">next</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># a delimited block immediately breaks the list unless preceded</span>
    <span class="ruby-comment"># by a list continuation (they are harsh like that ;0)</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">is_delimited_block?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-keyword">true</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:active</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-comment"># grab all the lines in the block, leaving the delimiters in place</span>
        <span class="ruby-comment"># we're being more strict here about the terminator, but I think that's a good thing</span>
        <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">match</span>.<span class="ruby-identifier">terminator</span>, <span class="ruby-value">:read_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
        <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-comment"># technically attr_line only breaks if ensuing line is not a list item</span>
    <span class="ruby-comment"># which really means attr_line only breaks if it's acting as a block delimiter</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:active</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>])
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:active</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-comment"># literal paragraphs have special considerations (and this is one of </span>
        <span class="ruby-comment"># two entry points into one)</span>
        <span class="ruby-comment"># if we don't process it as a whole, then a line in it that looks like a</span>
        <span class="ruby-comment"># list item will throw off the exit from it</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(
              <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
              <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
            <span class="ruby-comment"># we may be in an indented list disguised as a literal paragraph</span>
            <span class="ruby-comment"># so we need to make sure we don't slurp up a legitimate sibling</span>
            <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
          }
          <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>
        <span class="ruby-comment"># let block metadata play out until we find the block</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:blk_title</span>]) <span class="ruby-operator">||</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>]) <span class="ruby-operator">||</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_entry</span>])
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> = (<span class="ruby-identifier">within_nested_list</span> <span class="ruby-operator">?</span> [<span class="ruby-value">:dlist</span>] <span class="ruby-operator">:</span> <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>).<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
            <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-comment"># get greedy again</span>
              <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">prev_line</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prev_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-comment"># advance to the next line of content</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
          <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_line</span> 
          <span class="ruby-comment"># if we hit eof or a sibling, stop reading</span>
          <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
        <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
          <span class="ruby-identifier">detached_continuation</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-comment"># has_text is only relevant for dlist, which is more greedy until it has text for an item</span>
          <span class="ruby-comment"># for all other lists, has_text is always true</span>
          <span class="ruby-comment"># in this block, we have to see whether we stay in the list</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">has_text</span>
            <span class="ruby-comment"># slurp up any literal paragraph offset by blank lines</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
              <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span>
              <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">read_lines_until</span>(
                  <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                  <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                  <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
                <span class="ruby-comment"># we may be in an indented list disguised as a literal paragraph</span>
                <span class="ruby-comment"># so we need to make sure we don't slurp up a legitimate sibling</span>
                <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
              }
            <span class="ruby-comment"># TODO any way to combine this with the check after skipping blank lines?</span>
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
              <span class="ruby-keyword">break</span>
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">nested_list_type</span> = <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>.<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
              <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
              <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
              <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
                <span class="ruby-comment"># get greedy again</span>
                <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
              <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">else</span>
              <span class="ruby-keyword">break</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">else</span> <span class="ruby-comment"># only dlist in need of item text, so slurp it up!</span>
            <span class="ruby-comment"># pop the blank line so it's not interpretted as a list continuation</span>
            <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">within_nested_list</span>
            <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
            <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> = (<span class="ruby-identifier">within_nested_list</span> <span class="ruby-operator">?</span> [<span class="ruby-value">:dlist</span>] <span class="ruby-operator">:</span> <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>).<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
          <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-comment"># get greedy again</span>
            <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">this_line</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift_line</span> <span class="ruby-identifier">this_line</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">detached_continuation</span>
    <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">delete_at</span> <span class="ruby-identifier">detached_continuation</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># strip trailing blank lines to prevent empty blocks</span>
  <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">while</span> <span class="ruby-operator">!</span><span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-comment"># We do need to replace the optional trailing continuation</span>
  <span class="ruby-comment"># a blank line would have served the same purpose in the document</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
    <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment">#puts &quot;BUFFER[#{list_type},#{sibling_trait}]&gt;#{buffer.join}&lt;BUFFER&quot;</span>
  <span class="ruby-comment">#puts &quot;BUFFER[#{list_type},#{sibling_trait}]&gt;#{buffer.inspect}&lt;BUFFER&quot;</span>

  <span class="ruby-identifier">buffer</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- read_lines_for_list_item-source -->
          
        </div>

        

        
      </div><!-- read_lines_for_list_item-method -->

    
      <div id="method-c-resolve_list_marker" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">resolve_list_marker</span><span
            class="method-args">(list_type, marker, ordinal = 0, validate = false, reader = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Resolve the 0-index marker for this list item</p>

<p>For ordered lists, match the marker used for this list item against
theknown list markers and determine which marker is the first (0-index)
markerin its number series.</p>

<p>For callout lists, return &lt;1&gt;.</p>

<p>For bulleted lists, return the marker as passed to this method.</p>
<dl class="rdoc-list note-list"><dt>list_type
<dd>
<p>The Symbol context of the list</p>
</dd><dt>marker
<dd>
<p>The String marker for this list item</p>
</dd><dt>ordinal
<dd>
<p>The position of this list item in the list</p>
</dd><dt>validate
<dd>
<p>Whether to validate the value of the marker</p>
</dd></dl>

<p>Returns the String 0-index marker for this list item</p>
          
          

          
          <div class="method-source-code" id="resolve_list_marker-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1940</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">validate</span> = <span class="ruby-keyword">false</span>, <span class="ruby-identifier">reader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:olist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">marker</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'.'</span>)
    <span class="ruby-identifier">resolve_ordered_list_marker</span>(<span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span>, <span class="ruby-identifier">validate</span>, <span class="ruby-identifier">reader</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:colist</span>
    <span class="ruby-string">'&lt;1&gt;'</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">marker</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- resolve_list_marker-source -->
          
        </div>

        

        
      </div><!-- resolve_list_marker-method -->

    
      <div id="method-c-resolve_ordered_list_marker" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">resolve_ordered_list_marker</span><span
            class="method-args">(marker, ordinal = 0, validate = false, reader = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Resolve the 0-index marker for this ordered list item</p>

<p>Match the marker used for this ordered list item against theknown ordered
list markers and determine which marker isthe first (0-index) marker in its
number series.</p>

<p>The purpose of this method is to normalize the implicit numbered markersso
that they can be compared against other list items.</p>
<dl class="rdoc-list note-list"><dt>marker
<dd>
<p>The marker used for this list item</p>
</dd><dt>ordinal
<dd>
<p>The 0-based index of the list item (default: 0)</p>
</dd><dt>validate
<dd>
<p>Perform validation that the marker provided is the propermarker in the
sequence (default: false)</p>
</dd></dl>

<h3 id="method-c-resolve_ordered_list_marker-label-Examples">Examples<span><a href="#method-c-resolve_ordered_list_marker-label-Examples">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">marker</span> = <span class="ruby-string">'B.'</span>
<span class="ruby-constant">Lexer</span><span class="ruby-operator">::</span><span class="ruby-identifier">resolve_ordered_list_marker</span>(<span class="ruby-identifier">marker</span>, <span class="ruby-value">1</span>, <span class="ruby-keyword">true</span>)
<span class="ruby-comment"># =&gt; 'A.'</span>
</pre>

<p>Returns the String of the first marker in this number series</p>
          
          

          
          <div class="method-source-code" id="resolve_ordered_list_marker-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1971</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">resolve_ordered_list_marker</span>(<span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">validate</span> = <span class="ruby-keyword">false</span>, <span class="ruby-identifier">reader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">number_style</span> = <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">ORDERED_LIST_MARKER_PATTERNS</span>[<span class="ruby-identifier">s</span>]) }
  <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">actual</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">number_style</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:arabic</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'1.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:loweralpha</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = (<span class="ruby-string">'a'</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">ord</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ordinal</span>).<span class="ruby-identifier">chr</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">'.'</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'a.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:upperalpha</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = (<span class="ruby-string">'A'</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">ord</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ordinal</span>).<span class="ruby-identifier">chr</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">'.'</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'A.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:lowerroman</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-comment"># TODO report this in roman numerals; see https://github.com/jamesshipton/roman-numeral/blob/master/lib/roman_numeral.rb</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">')'</span>))
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'i)'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:upperroman</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-comment"># TODO report this in roman numerals; see https://github.com/jamesshipton/roman-numeral/blob/master/lib/roman_numeral.rb</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">')'</span>))
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'I)'</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">expected</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">actual</span>
    <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;asciidoctor: WARNING: #{reader.line_info}: list item index: expected #{expected}, got #{actual}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">marker</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- resolve_ordered_list_marker-source -->
          
        </div>

        

        
      </div><!-- resolve_ordered_list_marker-method -->

    
      <div id="method-c-roman_numeral_to_int" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">roman_numeral_to_int</span><span
            class="method-args">(value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Converts a Roman numeral to an integer value.</p>
<dl class="rdoc-list note-list"><dt>value
<dd>
<p>The String Roman numeral to convert</p>
</dd></dl>

<p>Returns the Integer for this Roman numeral</p>
          
          

          
          <div class="method-source-code" id="roman_numeral_to_int-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 2472</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">value</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">downcase</span>
  <span class="ruby-identifier">digits</span> = { <span class="ruby-string">'i'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-string">'v'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">5</span>, <span class="ruby-string">'x'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">10</span> }
  <span class="ruby-identifier">result</span> = <span class="ruby-value">0</span>
  
  (<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-identifier">value</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">digit</span> = <span class="ruby-identifier">digits</span>[<span class="ruby-identifier">value</span>[<span class="ruby-identifier">i</span><span class="ruby-operator">..</span><span class="ruby-identifier">i</span>]]
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">digits</span>[<span class="ruby-identifier">value</span>[<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>]] <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">digit</span>
      <span class="ruby-identifier">result</span> <span class="ruby-operator">-=</span> <span class="ruby-identifier">digit</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">result</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">digit</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- roman_numeral_to_int-source -->
          
        </div>

        

        
      </div><!-- roman_numeral_to_int-method -->

    
    </section><!-- public-class-method-details -->
  
  </section><!-- Internal -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.1.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

